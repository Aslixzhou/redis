<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>redis</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:first-child { margin-top: -20px; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


:root { --side-bar-bg-color: #fafafa; --control-text-color: #777; }
html { font-size: 16px; -webkit-font-smoothing: antialiased; }
body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, "Segoe UI Emoji", sans-serif; color: rgb(0, 64, 80); line-height: 1.6; }
#write { max-width: 860px; margin: 0px auto; padding: 30px 30px 100px; }
@media only screen and (min-width: 1400px) {
  #write { max-width: 1024px; }
}
@media only screen and (min-width: 1800px) {
  #write { max-width: 1200px; }
}
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }
h2 { font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 2px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border: 0px none; overflow: hidden; box-sizing: content-box; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left: 5px solid rgb(66, 185, 131); padding: 8px 15px; color: rgb(33, 93, 66); background-color: rgb(243, 245, 247); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; word-break: initial; }
table tr { border: 1px solid rgb(223, 226, 229); margin: 0px; padding: 0px; }
table tr:nth-child(2n), thead { background-color: rgb(248, 248, 248); }
table th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(223, 226, 229); border-right-color: rgb(223, 226, 229); border-left-color: rgb(223, 226, 229); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; margin: 0px; padding: 6px 13px; }
table td { border: 1px solid rgb(223, 226, 229); margin: 0px; padding: 6px 13px; }
table th:first-child, table td:first-child { margin-top: 0px; }
table th:last-child, table td:last-child { margin-bottom: 0px; }
.CodeMirror-lines { padding-left: 4px; }
.code-tooltip { box-shadow: rgba(0, 28, 36, 0.3) 0px 1px 1px 0px; border-top: 1px solid rgb(238, 242, 242); }
.md-fences, code, tt { border: 1px solid rgb(231, 234, 237); background-color: rgb(248, 248, 248); border-radius: 3px; padding: 2px 4px 0px; font-size: 0.9em; }
code { background-color: rgb(243, 244, 244); padding: 2px; color: rgb(209, 37, 115); }
.md-fences { margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px; }
.md-task-list-item > input { margin-left: -1.3em; }
@media print {
  html { font-size: 13px; }
  table, pre { break-inside: avoid; }
  pre { word-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
.md-mathjax-midline { background: rgb(250, 250, 250); }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; }
.md-tag { color: rgb(167, 167, 167); opacity: 1; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
.sidebar-tabs { border-bottom: none; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; }
.on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); }
header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; }
.file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; }
.mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); }
.md-lang { color: rgb(180, 101, 77); }
#md-notification .btn { border: 0px; }
.dropdown-menu .divider { border-color: rgb(229, 229, 229); opacity: 0.4; }
.ty-preferences .window-content { background-color: rgb(250, 250, 250); }
.ty-preferences .nav-group-item.active { color: white; background: rgb(153, 153, 153); }
.menu-item-container a.menu-style-btn { background-color: rgb(245, 248, 250); background-image: linear-gradient(rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0)); }
#write mark { background: transparent; color: rgb(216, 105, 105); font-weight: bold; }
p .md-image:only-child { width: auto; text-align: left; }


.cm-s-inner { background-color: rgb(38, 50, 56); color: rgb(233, 237, 237); }
.cm-s-inner .CodeMirror-gutters { background: rgb(38, 50, 56); color: rgb(83, 127, 126); border: none; }
.cm-s-inner .CodeMirror-guttermarker, .cm-s-inner .CodeMirror-guttermarker-subtle, .cm-s-inner .CodeMirror-linenumber { color: rgb(83, 127, 126); }
.cm-s-inner .CodeMirror-cursor { border-left: 1px solid rgb(248, 248, 240); }
.cm-s-inner div.CodeMirror-selected { background: rgba(255, 255, 255, 0.15); }
.cm-s-inner.CodeMirror-focused div.CodeMirror-selected { background: rgba(255, 255, 255, 0.1); }
.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line > span::selection, .cm-s-inner .CodeMirror-line > span > span::selection { background: rgba(255, 255, 255, 0.1); }
.cm-s-inner .CodeMirror-activeline-background { background: rgba(0, 0, 0, 0); }
.cm-s-inner .cm-keyword { color: rgb(199, 146, 234); }
.cm-s-inner .cm-operator { color: rgb(233, 237, 237); }
.cm-s-inner .cm-variable-2 { color: rgb(128, 203, 196); }
.cm-s-inner .cm-variable-3 { color: rgb(158, 255, 255); }
.cm-s-inner .cm-builtin { color: rgb(222, 203, 107); }
.cm-s-inner .cm-atom { color: rgb(247, 118, 105); }
.cm-s-inner .cm-number { color: rgb(247, 118, 105); }
.cm-s-inner .cm-def { color: rgb(233, 237, 237); }
.cm-s-inner .cm-string { color: rgb(195, 232, 141); }
.cm-s-inner .cm-string-2 { color: rgb(128, 203, 196); }
.cm-s-inner .cm-comment { color: rgb(84, 110, 122); }
.cm-s-inner .cm-variable { color: rgb(158, 255, 255); }
.cm-s-inner .cm-tag { color: rgb(128, 203, 196); }
.cm-s-inner .cm-meta { color: rgb(128, 203, 196); }
.cm-s-inner .cm-attribute { color: rgb(255, 203, 107); }
.cm-s-inner .cm-property { color: rgb(128, 203, 174); }
.cm-s-inner .cm-qualifier { color: rgb(222, 203, 107); }
.cm-s-inner .cm-variable-3 { color: rgb(222, 203, 107); }
.cm-s-inner .cm-tag { color: rgb(255, 83, 112); }
.cm-s-inner .cm-error { color: rgb(255, 255, 255); background-color: rgb(236, 95, 103); }
.cm-s-inner .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }
.md-fences { background-color: rgb(38, 50, 56); color: rgb(233, 237, 237); border: none; }
.md-fences .code-tooltip { background-color: rgb(38, 50, 56); }




</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node first-line-indent'><h1><a name='header-n0' class='md-header-anchor '></a>Redis</h1><blockquote><p>Author：Zhry</p><p>Email：<a href='mailto:2553179694@qq.com' target='_blank' class='url'>2553179694@qq.com</a></p><p>Version：2.0.3</p></blockquote><p><strong><em>Redis</em></strong> 是典型的 <strong><em>NoSQL</em></strong> 数据库。</p><p><strong><em>redis官网</em></strong>：<a href='https://redis.io/download' target='_blank' class='url'>https://redis.io/download</a> </p><blockquote><p><strong><em>Redis</em></strong> 是一个开源的 <strong><em>key-value</em></strong> 存储系统。</p><p>和 <strong><em>Memcached</em></strong> 类似，它支持存储的 <strong><em>value</em></strong> 类型相对更多，包括 <strong><em>string、list、set、zset、sorted set、hash</em></strong>。</p><p>这些数据类型都支持 <strong><em>push/pop、add/remove</em></strong> 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p><p>在此基础上，<strong><em>Redis</em></strong> 支持各种不同方式的排序。</p><p>与 <strong><em>memcached</em></strong>一样，为了保证效率，数据都是缓存在内存中。</p><p>区别的是 <strong><em>Redis</em></strong> 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p><p>并且在此基础上实现了<strong><em>master-slave</em></strong> （主从）同步。</p><p>单线程 + <strong><em>IO</em></strong> 多路复用。</p></blockquote><div class='md-toc' mdtype='toc'><p class="md-toc-content"><span class="md-toc-item md-toc-h1" data-ref="n0"><a class="md-toc-inner" href="#header-n0">Redis</a></span><span class="md-toc-item md-toc-h1" data-ref="n18"><a class="md-toc-inner" href="#header-n18">1. 安装和启动</a></span><span class="md-toc-item md-toc-h1" data-ref="n57"><a class="md-toc-inner" href="#header-n57">2. NoSQL数据库</a></span><span class="md-toc-item md-toc-h1" data-ref="n101"><a class="md-toc-inner" href="#header-n101">3. 配置文件</a></span><span class="md-toc-item md-toc-h2" data-ref="n103"><a class="md-toc-inner" href="#header-n103">3.1 <strong><em>Units</em></strong> </a></span><span class="md-toc-item md-toc-h2" data-ref="n108"><a class="md-toc-inner" href="#header-n108">3.2 <strong><em>INCLUDES</em></strong></a></span><span class="md-toc-item md-toc-h2" data-ref="n112"><a class="md-toc-inner" href="#header-n112">3.3 <strong><em>NETWORK</em></strong></a></span><span class="md-toc-item md-toc-h2" data-ref="n139"><a class="md-toc-inner" href="#header-n139">3.4 <strong><em>GENERAL</em></strong></a></span><span class="md-toc-item md-toc-h2" data-ref="n158"><a class="md-toc-inner" href="#header-n158">3.5 <strong><em>SECURITY</em></strong></a></span><span class="md-toc-item md-toc-h2" data-ref="n166"><a class="md-toc-inner" href="#header-n166">3.6 <strong><em>LIMITS</em></strong></a></span><span class="md-toc-item md-toc-h1" data-ref="n193"><a class="md-toc-inner" href="#header-n193">4. 常用五大基本数据类型</a></span><span class="md-toc-item md-toc-h2" data-ref="n194"><a class="md-toc-inner" href="#header-n194">4.1 key操作</a></span><span class="md-toc-item md-toc-h2" data-ref="n207"><a class="md-toc-inner" href="#header-n207">4.2 字符串（String）</a></span><span class="md-toc-item md-toc-h3" data-ref="n208"><a class="md-toc-inner" href="#header-n208">4.2.1 概述</a></span><span class="md-toc-item md-toc-h3" data-ref="n211"><a class="md-toc-inner" href="#header-n211">4.2.2 常用命令</a></span><span class="md-toc-item md-toc-h2" data-ref="n242"><a class="md-toc-inner" href="#header-n242">4.3 列表（List）</a></span><span class="md-toc-item md-toc-h2" data-ref="n267"><a class="md-toc-inner" href="#header-n267">4.4 Set（集合）</a></span><span class="md-toc-item md-toc-h2" data-ref="n285"><a class="md-toc-inner" href="#header-n285">4.5 Hash（哈希）</a></span><span class="md-toc-item md-toc-h2" data-ref="n302"><a class="md-toc-inner" href="#header-n302">4.6 Zset（有序集合）</a></span><span class="md-toc-item md-toc-h1" data-ref="n346"><a class="md-toc-inner" href="#header-n346">5. Redis6新数据结构</a></span><span class="md-toc-item md-toc-h2" data-ref="n347"><a class="md-toc-inner" href="#header-n347">5.1 Bitmaps</a></span><span class="md-toc-item md-toc-h2" data-ref="n401"><a class="md-toc-inner" href="#header-n401">5.2 Bitmaps与set对比</a></span><span class="md-toc-item md-toc-h2" data-ref="n468"><a class="md-toc-inner" href="#header-n468">5.3 HyperLogLog</a></span><span class="md-toc-item md-toc-h2" data-ref="n488"><a class="md-toc-inner" href="#header-n488">5.4 Geospatial</a></span><span class="md-toc-item md-toc-h1" data-ref="n510"><a class="md-toc-inner" href="#header-n510">6. Redis的发布与订阅</a></span><span class="md-toc-item md-toc-h1" data-ref="n524"><a class="md-toc-inner" href="#header-n524">7. 事务和锁机制</a></span><span class="md-toc-item md-toc-h2" data-ref="n529"><a class="md-toc-inner" href="#header-n529">7.1 <em>Multi</em>、<em>Exec</em>、<em>Discard</em></a></span><span class="md-toc-item md-toc-h2" data-ref="n552"><a class="md-toc-inner" href="#header-n552">7.2 悲观锁</a></span><span class="md-toc-item md-toc-h2" data-ref="n555"><a class="md-toc-inner" href="#header-n555">7.3 乐观锁</a></span><span class="md-toc-item md-toc-h2" data-ref="n560"><a class="md-toc-inner" href="#header-n560">7.4 <em>Watch、unwatch</em></a></span><span class="md-toc-item md-toc-h2" data-ref="n566"><a class="md-toc-inner" href="#header-n566">7.5 事务三特性</a></span><span class="md-toc-item md-toc-h2" data-ref="n579"><a class="md-toc-inner" href="#header-n579">7.6 Redis事务秒杀案例</a></span><span class="md-toc-item md-toc-h1" data-ref="n615"><a class="md-toc-inner" href="#header-n615">8. 持久化</a></span><span class="md-toc-item md-toc-h2" data-ref="n616"><a class="md-toc-inner" href="#header-n616">8.1 RDB</a></span><span class="md-toc-item md-toc-h3" data-ref="n624"><a class="md-toc-inner" href="#header-n624">8.1.2 Fork</a></span><span class="md-toc-item md-toc-h3" data-ref="n633"><a class="md-toc-inner" href="#header-n633">8.1.3 配置</a></span><span class="md-toc-item md-toc-h3" data-ref="n658"><a class="md-toc-inner" href="#header-n658">8.1.4 命令</a></span><span class="md-toc-item md-toc-h3" data-ref="n674"><a class="md-toc-inner" href="#header-n674">8.1.5 rdb备份</a></span><span class="md-toc-item md-toc-h3" data-ref="n689"><a class="md-toc-inner" href="#header-n689">8.1.6 优点</a></span><span class="md-toc-item md-toc-h3" data-ref="n699"><a class="md-toc-inner" href="#header-n699">8.1.7 缺点</a></span><span class="md-toc-item md-toc-h2" data-ref="n708"><a class="md-toc-inner" href="#header-n708">8.2 AOF</a></span><span class="md-toc-item md-toc-h3" data-ref="n722"><a class="md-toc-inner" href="#header-n722">8.2.1 配置</a></span><span class="md-toc-item md-toc-h3" data-ref="n782"><a class="md-toc-inner" href="#header-n782">8.2.2 优点</a></span><span class="md-toc-item md-toc-h3" data-ref="n789"><a class="md-toc-inner" href="#header-n789">8.2.3 缺点</a></span><span class="md-toc-item md-toc-h2" data-ref="n799"><a class="md-toc-inner" href="#header-n799">8.3 选择</a></span><span class="md-toc-item md-toc-h2" data-ref="n805"><a class="md-toc-inner" href="#header-n805">8.4 官方建议</a></span><span class="md-toc-item md-toc-h1" data-ref="n821"><a class="md-toc-inner" href="#header-n821">9. 主从复制</a></span><span class="md-toc-item md-toc-h2" data-ref="n833"><a class="md-toc-inner" href="#header-n833">9.1 搭建一主两从</a></span><span class="md-toc-item md-toc-h2" data-ref="n890"><a class="md-toc-inner" href="#header-n890">9.2 一主二仆</a></span><span class="md-toc-item md-toc-h2" data-ref="n902"><a class="md-toc-inner" href="#header-n902">9.3 薪火相传</a></span><span class="md-toc-item md-toc-h2" data-ref="n910"><a class="md-toc-inner" href="#header-n910">9.4 反客为主</a></span><span class="md-toc-item md-toc-h2" data-ref="n914"><a class="md-toc-inner" href="#header-n914">9.5 哨兵模式</a></span><span class="md-toc-item md-toc-h3" data-ref="n943"><a class="md-toc-inner" href="#header-n943">9.5.1 选举规则</a></span><span class="md-toc-item md-toc-h3" data-ref="n956"><a class="md-toc-inner" href="#header-n956">9.5.2 复制延时</a></span><span class="md-toc-item md-toc-h2" data-ref="n959"><a class="md-toc-inner" href="#header-n959">9.6 复制原理</a></span><span class="md-toc-item md-toc-h2" data-ref="n974"><a class="md-toc-inner" href="#header-n974">9.7 Java代码</a></span><span class="md-toc-item md-toc-h1" data-ref="n977"><a class="md-toc-inner" href="#header-n977">10. 集群</a></span><span class="md-toc-item md-toc-h2" data-ref="n991"><a class="md-toc-inner" href="#header-n991">10.1 搭建 <em>Redis</em> 集群</a></span><span class="md-toc-item md-toc-h2" data-ref="n1029"><a class="md-toc-inner" href="#header-n1029">10.2 问题</a></span><span class="md-toc-item md-toc-h3" data-ref="n1030"><a class="md-toc-inner" href="#header-n1030">10.2.1 <em>redis cluster</em> 如何分配这六个节点?</a></span><span class="md-toc-item md-toc-h3" data-ref="n1036"><a class="md-toc-inner" href="#header-n1036">10.2.2 什么是 <em>slots</em>？</a></span><span class="md-toc-item md-toc-h3" data-ref="n1050"><a class="md-toc-inner" href="#header-n1050">10.2.3 如何在集群中录入值？</a></span><span class="md-toc-item md-toc-h3" data-ref="n1059"><a class="md-toc-inner" href="#header-n1059">10.2.4 如何查询集群中的值？</a></span><span class="md-toc-item md-toc-h3" data-ref="n1065"><a class="md-toc-inner" href="#header-n1065">10.2.5 故障恢复？</a></span><span class="md-toc-item md-toc-h2" data-ref="n1085"><a class="md-toc-inner" href="#header-n1085">10.3 优点</a></span><span class="md-toc-item md-toc-h2" data-ref="n1093"><a class="md-toc-inner" href="#header-n1093">10.4 缺点</a></span><span class="md-toc-item md-toc-h2" data-ref="n1101"><a class="md-toc-inner" href="#header-n1101">10.5 <em>Jedis</em>集群</a></span><span class="md-toc-item md-toc-h1" data-ref="n1107"><a class="md-toc-inner" href="#header-n1107">11. Jedis操作Redis</a></span><span class="md-toc-item md-toc-h2" data-ref="n1133"><a class="md-toc-inner" href="#header-n1133">11.1 手机验证码发送模拟</a></span><span class="md-toc-item md-toc-h2" data-ref="n1137"><a class="md-toc-inner" href="#header-n1137">11.2 <em>Jedis</em> 主从复制</a></span><span class="md-toc-item md-toc-h2" data-ref="n1139"><a class="md-toc-inner" href="#header-n1139">11.3 集群的 <em>Jedis</em> 开发</a></span><span class="md-toc-item md-toc-h1" data-ref="n1143"><a class="md-toc-inner" href="#header-n1143">12. SpringBoot整合Redis</a></span><span class="md-toc-item md-toc-h1" data-ref="n1160"><a class="md-toc-inner" href="#header-n1160">13. 应用问题解决</a></span><span class="md-toc-item md-toc-h2" data-ref="n1161"><a class="md-toc-inner" href="#header-n1161">13.1 缓存穿透</a></span><span class="md-toc-item md-toc-h3" data-ref="n1163"><a class="md-toc-inner" href="#header-n1163">13.1.1 现象</a></span><span class="md-toc-item md-toc-h3" data-ref="n1174"><a class="md-toc-inner" href="#header-n1174">13.1.2 如何解决</a></span><span class="md-toc-item md-toc-h2" data-ref="n1191"><a class="md-toc-inner" href="#header-n1191">13.2 缓存击穿</a></span><span class="md-toc-item md-toc-h3" data-ref="n1192"><a class="md-toc-inner" href="#header-n1192">13.2.1 现象</a></span><span class="md-toc-item md-toc-h3" data-ref="n1201"><a class="md-toc-inner" href="#header-n1201">13.2.2 如何解决</a></span><span class="md-toc-item md-toc-h2" data-ref="n1217"><a class="md-toc-inner" href="#header-n1217">13.3 缓存雪崩</a></span><span class="md-toc-item md-toc-h3" data-ref="n1218"><a class="md-toc-inner" href="#header-n1218">13.3.1 现象</a></span><span class="md-toc-item md-toc-h3" data-ref="n1226"><a class="md-toc-inner" href="#header-n1226">13.3.2 如何解决</a></span><span class="md-toc-item md-toc-h2" data-ref="n1241"><a class="md-toc-inner" href="#header-n1241">13.4 分布式锁</a></span><span class="md-toc-item md-toc-h3" data-ref="n1242"><a class="md-toc-inner" href="#header-n1242">13.4.1 问题描述</a></span><span class="md-toc-item md-toc-h3" data-ref="n1261"><a class="md-toc-inner" href="#header-n1261">13.4.2 redis实现分布式锁</a></span><span class="md-toc-item md-toc-h3" data-ref="n1279"><a class="md-toc-inner" href="#header-n1279">13.4.3 Java代码</a></span><span class="md-toc-item md-toc-h3" data-ref="n1286"><a class="md-toc-inner" href="#header-n1286">13.4.4 设置过期时间</a></span><span class="md-toc-item md-toc-h3" data-ref="n1308"><a class="md-toc-inner" href="#header-n1308">13.4.5 优化之UUID防误删</a></span><span class="md-toc-item md-toc-h3" data-ref="n1327"><a class="md-toc-inner" href="#header-n1327">13.4.6 优化之LUA脚本保证删除的原子性</a></span><span class="md-toc-item md-toc-h3" data-ref="n1339"><a class="md-toc-inner" href="#header-n1339">13.4.7 总结</a></span><span class="md-toc-item md-toc-h1" data-ref="n1362"><a class="md-toc-inner" href="#header-n1362">14. Redis6新特性</a></span><span class="md-toc-item md-toc-h2" data-ref="n1363"><a class="md-toc-inner" href="#header-n1363">14.1 ACL</a></span><span class="md-toc-item md-toc-h3" data-ref="n1364"><a class="md-toc-inner" href="#header-n1364">14.1.1 简介</a></span><span class="md-toc-item md-toc-h3" data-ref="n1372"><a class="md-toc-inner" href="#header-n1372">14.1.2 命令</a></span><span class="md-toc-item md-toc-h2" data-ref="n1440"><a class="md-toc-inner" href="#header-n1440">14.2 IO多线程</a></span><span class="md-toc-item md-toc-h3" data-ref="n1441"><a class="md-toc-inner" href="#header-n1441">14.2.1 简介</a></span><span class="md-toc-item md-toc-h3" data-ref="n1444"><a class="md-toc-inner" href="#header-n1444">14.2.2 原理架构</a></span><span class="md-toc-item md-toc-h3" data-ref="n1450"><a class="md-toc-inner" href="#header-n1450">14.2.3 工具支持Cluster</a></span><span class="md-toc-item md-toc-h2" data-ref="n1453"><a class="md-toc-inner" href="#header-n1453">14.3 Redis新功能持续关注</a></span><span class="md-toc-item md-toc-h1" data-ref="n1462"><a class="md-toc-inner" href="#header-n1462">15. 后会有期</a></span></p></div><h1><a name='header-n18' class='md-header-anchor '></a>1. 安装和启动</h1><blockquote><p>安装 <strong><em>C</em></strong> 语言的编译环境</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="base"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="base"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">yum install centos-release-scl scl-utils-build</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">yum install -y devtoolset-8-toolchain</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">scl enable devtoolset-8 bash</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 113px;"></div><div class="CodeMirror-gutters" style="display: none; height: 113px;"></div></div></div></pre><p>通过 <strong><em>wget</em></strong> 下载</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">wget https://download.redis.io/releases/redis-6.2.6.tar.gz</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 下载路径：/opt</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 113px;"></div><div class="CodeMirror-gutters" style="display: none; height: 113px;"></div></div></div></pre><p>解压至当前目录</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">tar -zxvf redis-6.2.6.tar.gz </span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p>解压完成后进入目录</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">cd redis-6.2.6</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p>在当前目录下执行 <strong><em>make</em></strong></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">make &amp;&amp; make install</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p>默认安装在 <code>/usr/local/bin</code></p><p><img src='https://img-blog.csdnimg.cn/a38c42b199ba4abfa18bbc61da85e5d3.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">redis-benchmark：性能测试工具，可以在自己本子运行，看看自己本子性能如何</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">redis-check-dump：修复有问题的dump.rdb文件</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">redis-sentinel：Redis集群使用</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">redis-server：Redis服务器启动命令</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">redis-cli：客户端，操作入口</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 203px;"></div><div class="CodeMirror-gutters" style="display: none; height: 203px;"></div></div></div></pre><p>前台启动：<strong><em>/usr/local/bin</em></strong> 目录下启动 <strong><em>redis</em></strong></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="bash"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="bash"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">redis-server(前台启动)</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p>后台启动：</p><ul><li>安装 <strong><em>redis</em></strong> 的目录 <strong><em>/opt/redis-6.2.6</em></strong> 中将 <strong><em>redis.conf</em></strong> 复制到任意一个文件夹下</li></ul><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">cp redis.conf /etc/redis.conf</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 将redis.conf复制到/etc/下</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 45px;"></div><div class="CodeMirror-gutters" style="display: none; height: 45px;"></div></div></div></pre><ul><li>修改 <strong><em>/etc/redis.conf</em></strong> 配置文件</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="bash" contenteditable="false" cid="n43" mdtype="fences">vim redis.conf

# daemonize no 修改为 daemonize yes
</pre></blockquote><p>&nbsp;</p><blockquote><p>/usr/local/bin目录下启动redis</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="bash" contenteditable="false" cid="n47" mdtype="fences">redis-server /etc/redis.conf
</pre><p>关闭 <strong><em>redis</em></strong></p><ul><li><strong><em>kill</em></strong> 进程</li><li>命令 <strong><em>shutdown</em></strong></li></ul></blockquote><p>&nbsp;</p><p><u><strong>默认端口号：6379</strong></u></p><p>&nbsp;</p><h1><a name='header-n57' class='md-header-anchor '></a>2. NoSQL数据库</h1><ul><li><p>解决 <strong><em>CPU</em></strong> 及内存压力</p><p><img src='https://img-blog.csdnimg.cn/5933a1b4566340ea84804e04bc4da57e.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' />解决 <strong><em>IO</em></strong> 压力</p><p><img src='https://img-blog.csdnimg.cn/61c65bdc52b24940a893e29177b34b1b.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></li></ul><p><strong><em>NoSQL（ NoSQL = Not Only SQL ）</em></strong>，意即不仅仅是 <strong><em>SQL</em></strong>，泛指非关系型的数据库。 </p><p><strong><em>NoSQL</em></strong> 不依赖业务逻辑方式存储，而以简单的 <strong><em>key-value</em></strong> 模式存储。因此大大的增加了数据库的扩展能力。</p><ul><li>不遵循 <strong><em>SQL</em></strong> 标准。</li><li>不支持 <strong><em>ACID</em></strong>。</li><li>远超于 <strong><em>SQL</em></strong> 的性能。</li></ul><p>&nbsp;</p><p><strong>适用于的场景</strong></p><ul><li>对数据高并发的读写；</li><li>海量数据的读写；</li><li>对数据高可扩展性的。</li></ul><p><strong>不适用的场景</strong></p><ul><li>需要事务支持；</li><li>基于 <strong><em>sql</em></strong> 的结构化查询存储，处理复杂的关系，需要即席查询。</li></ul><p>&nbsp;</p><p>常见的 <strong><em>NoSQL</em></strong> 数据库</p><ul><li>Redis</li><li>MongoDB</li></ul><p>大数据时代常用的数据库类型</p><ul><li><p>行式数据库</p><p><img src='https://img-blog.csdnimg.cn/9dbb1c3cc448431aa846f6bf81c40c3b.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' />列式数据库</p><p><img src='https://img-blog.csdnimg.cn/f8f788c039054b44993de69e1bae3a59.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></li></ul><h1><a name='header-n101' class='md-header-anchor '></a>3. 配置文件</h1><p><strong><em>redis.conf</em></strong></p><h2><a name='header-n103' class='md-header-anchor '></a>3.1 <strong><em>Units</em></strong> </h2><blockquote><p>单位，配置大小单位，开头定义了一些基本的度量单位，只支持 <strong><em>bytes</em></strong>，不支持 <strong><em>bit</em></strong>。</p><p>大小写不敏感。</p></blockquote><p><img src='https://img-blog.csdnimg.cn/aeafc8c6b83d4a2ea56e4bf725d5cfb7.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><h2><a name='header-n108' class='md-header-anchor '></a>3.2 <strong><em>INCLUDES</em></strong></h2><blockquote><p>包含，多实例的情况可以把公用的配置文件提取出来。</p></blockquote><p><img src='https://img-blog.csdnimg.cn/51dbc3395dad481ea6b5ed6ce5a54f82.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><h2><a name='header-n112' class='md-header-anchor '></a>3.3 <strong><em>NETWORK</em></strong></h2><blockquote><p>网络相关配置。</p><p><strong><em>bind</em></strong></p><p>默认情况 <code>bind=127.0.0.1</code> 只能接受本机的访问请求。</p><p>不写的情况下，无限制接受任何 <strong><em>ip</em></strong> 地址的访问。</p><p>生产环境肯定要写你应用服务器的地址，服务器是需要远程访问的，<em><u>所以需要将其注释掉</u></em>。</p><p>如果开启了<strong><em>protected-mode</em></strong>，那么在没有设定 <strong><em>bind ip</em></strong> 且没有设密码的情况下，<strong><em>Redis</em></strong> 只允许接受本机的响应。</p><p><img src='https://img-blog.csdnimg.cn/106224c2245d4568aa448973b71cceb7.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong><em>protected-mode</em></strong></p><p>将本机访问保护模式设置 <strong><em>no</em></strong>。</p><p><img src='https://img-blog.csdnimg.cn/4bc37a15f91f48d0872bc9c153c8c20a.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>port</em></strong></p><p>端口号，默认 <strong><em>6379</em></strong>。</p><p><img src='https://img-blog.csdnimg.cn/74d7461142234159be43c4d5bc6d35b7.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>tcp-backlog</em></strong></p><p>设置 <strong><em>tcp</em></strong> 的 <strong><em>backlog</em></strong>，<strong><em>backlog</em></strong> 其实是一个连接队列，<strong><em>backlog</em></strong> 队列总和 <span class="MathJax_SVG" tabindex="-1" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.807ex" height="1.177ex" viewBox="0 -454.3 778 506.6" role="img" focusable="false" style="vertical-align: 0.309ex; margin-bottom: -0.43ex;"><defs><path stroke-width="0" id="E1-MJMAIN-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E1-MJMAIN-3D" x="0" y="0"></use></g></svg></span><script type="math/tex">=</script> 未完成三次握手队列 <span class="MathJax_SVG" tabindex="-1" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.807ex" height="1.877ex" viewBox="0 -655.4 778 808.1" role="img" focusable="false" style="vertical-align: -0.355ex;"><defs><path stroke-width="0" id="E2-MJMAIN-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E2-MJMAIN-2B" x="0" y="0"></use></g></svg></span><script type="math/tex">+</script> 已经完成三次握手队列。</p><p>在高并发环境下你需要一个高 <strong><em>backlog</em></strong> 值来避免慢客户端连接问题。</p><p><img src='https://img-blog.csdnimg.cn/d4bebea709b145e0af098c5b53e47fd2.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>timeout</em></strong></p><p>一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭。</p><p><img src='https://img-blog.csdnimg.cn/e6b27cf1070d4b68a2f690462539d161.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>tcp-keepalive</em></strong></p><p>对访问客户端的一种心跳检测，每个 <strong><em>n</em></strong> 秒检测一次。</p><p>单位为秒，如果设置为 0，则不会进行 <strong><em>Keepalive</em></strong> 检测，建议设置成 60。</p><p><img src='https://img-blog.csdnimg.cn/04d2d8d94b114932a44e08379f630597.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></blockquote><h2><a name='header-n139' class='md-header-anchor '></a>3.4 <strong><em>GENERAL</em></strong></h2><blockquote><p>通用。</p><p><strong><em>daemonize</em></strong></p><p>是否为后台进程，设置为 <strong><em>yes</em></strong>。</p><p>守护进程，后台启动。</p><p><img src='https://img-blog.csdnimg.cn/9ef07e150e0d4a71b89b05d4be2852ce.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>pidfile</em></strong></p><p>存放 <strong><em>pid</em></strong> 文件的位置，每个实例会产生一个不同的 <strong><em>pid</em></strong> 文件。</p><p><img src='https://img-blog.csdnimg.cn/94ce8b55526d4a94b4b938f9ec4fc671.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>loglevel</em></strong></p><p>指定日志记录级别，<strong><em>Redis</em></strong> 总共支持四个级别：<strong><em>debug、verbose、notice、warning</em></strong>，默认为 <strong><em>notice</em></strong>。</p><p><img src='https://img-blog.csdnimg.cn/c04d4179da3e415bb83ccb52583497b7.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>logfile</em></strong></p><p>日志文件名称。</p><p><img src='https://img-blog.csdnimg.cn/45e5f8919b8d4de3b4e45fd538d005a2.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>database</em></strong></p><p>设定库的数量 默认16，默认数据库为 0，可以使用 <code>SELECT &lt;dbid&gt;</code> 命令在连接上指定数据库 <strong><em>id</em></strong>。</p><p><img src='https://img-blog.csdnimg.cn/2545f9e2504647c2a19c2353c7f23df3.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></blockquote><h2><a name='header-n158' class='md-header-anchor '></a>3.5 <strong><em>SECURITY</em></strong></h2><blockquote><p>安全。</p><p>访问密码的查看、设置和取消。</p><p>在命令中设置密码，只是临时的。重启 <strong><em>redis</em></strong> 服务器，密码就还原了。</p><p>永久设置，需要在配置文件中进行设置。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="bash" contenteditable="false" cid="n164" mdtype="fences">requirepass 2553179694
</pre></blockquote><p>&nbsp;</p><h2><a name='header-n166' class='md-header-anchor '></a>3.6 <strong><em>LIMITS</em></strong></h2><blockquote><p>限制。</p><p><strong><em>maxclients</em></strong></p><p>设置 <strong><em>redis</em></strong> 同时可以与多少个客户端进行连接。</p><p>默认情况下为 <strong><em>10000</em></strong> 个客户端。</p><p>如果达到了此限制，<strong><em>redis</em></strong> 则会拒绝新的连接请求，并且向这些连接请求方发出 <strong><em>max number of clients reached</em></strong> 以作回应。</p><p><img src='https://img-blog.csdnimg.cn/52d9c21e3f744b2cb4b221992647de6c.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>maxmemory</em></strong></p><p>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机。</p><p>设置 <strong><em>redis</em></strong> 可以使用的内存量。一旦到达内存使用上限，<strong><em>redis</em></strong> 将会试图移除内部数据，移除规则可以通过 <strong><em>maxmemory-policy</em></strong> 来指定。</p><p>如果 <strong><em>redis</em></strong> 无法根据移除规则来移除内存中的数据，或者设置了不允许移除，那么 <strong><em>redis</em></strong> 则会针对那些需要申请内存的指令返回错误信息，比如 <strong><em>SET、LPUSH</em></strong> 等。</p><p>但是对于无内存申请的指令，仍然会正常响应，比如 <strong><em>GET</em></strong> 等。如果你的 <strong><em>redis</em></strong> 是主 <strong><em>redis</em></strong>（ 说明你的 <strong><em>redis</em></strong> 有从 <strong><em>redis</em></strong> ），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p><p><img src='https://img-blog.csdnimg.cn/ca68ef28fdb54ae5b888110f7f038747.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>maxmemory-policy</em></strong></p><p><strong><em>volatile-lru</em></strong>：使用 <strong><em>LRU</em></strong> 算法移除 <strong><em>key</em></strong>，只对设置了过期时间的键（最近最少使用）。</p><p><strong><em>allkeys-lru</em></strong>：在所有集合 <strong><em>key</em></strong> 中，使用 <strong><em>LRU</em></strong> 算法移除 <strong><em>key</em></strong>。</p><p><strong><em>volatile-random</em></strong>：在过期集合中移除随机的 <strong><em>key</em></strong>，只对设置了过期时间的键。</p><p><strong><em>allkeys-random</em></strong>：在所有集合 <strong><em>key</em></strong> 中，移除随机的 <strong><em>key</em></strong>。</p><p><strong><em>volatile-ttl</em></strong>：移除那些 <strong><em>TTL</em></strong> 值最小的 <strong><em>key</em></strong>，即那些最近要过期的 <strong><em>key</em></strong>。</p><p><strong><em>noeviction</em></strong>：不进行移除。针对写操作，只是返回错误信息。</p><p><img src='https://img-blog.csdnimg.cn/4fad204d6cb14b44a50aaf3a95e63815.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>maxmemory-samples</em></strong></p><p>设置样本数量，<strong><em>LRU</em></strong> 算法和最小 <strong><em>TTL</em></strong> 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，<strong><em>redis</em></strong> 默认会检查这么多个 <strong><em>key</em></strong> 并选择其中 <strong><em>LRU</em></strong> 的那个。</p><p>一般设置 3 到 7 的数字，数值越小样本越不准确，但性能消耗越小。</p><p><img src='https://img-blog.csdnimg.cn/e3c3d7795b8c4920be073f91edeeaba9.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></blockquote><p>&nbsp;</p><h1><a name='header-n193' class='md-header-anchor '></a>4. 常用五大基本数据类型</h1><h2><a name='header-n194' class='md-header-anchor '></a>4.1 key操作</h2><blockquote><p><code>keys *</code>：查看当前库所有 <strong><em>key</em></strong>  </p><p><code>exists key</code>：判断某个 <strong><em>key</em></strong> 是否存在</p><p><code>type key</code>：查看你的 <strong><em>key</em></strong> 是什么类型</p><p><code>del key</code> ：删除指定的 <strong><em>key</em></strong> 数据</p><p><code>unlink key</code>：根据 <strong><em>value</em></strong> 选择非阻塞删除，仅将 <strong><em>keys</em></strong> 从 <strong><em>keyspace</em></strong> 元数据中删除，真正的删除会在后续异步操作</p><p><code>expire key 10</code> ：为给定的 <strong><em>key</em></strong> 设置过期时间</p><p><code>ttl key</code>：查看还有多少秒过期，-1表示永不过期，-2表示已过期</p><p><code>select</code>：命令切换数据库</p><p><code>dbsize</code>：查看当前数据库的 <strong><em>key</em></strong> 的数量</p><p><code>flushdb</code>：清空当前库</p><p><code>flushall</code>：通杀全部库</p></blockquote><h2><a name='header-n207' class='md-header-anchor '></a>4.2 字符串（String）</h2><h3><a name='header-n208' class='md-header-anchor '></a>4.2.1 概述</h3><p><strong><em>String</em></strong> 类型是二进制安全的。意味着 <strong><em>Redis</em></strong> 的 <strong><em>string</em></strong> 可以包含任何数据。比如 <strong><em>jpg</em></strong> 图片或者序列化的对象。</p><p><strong><em>String</em></strong> 类型是 <strong><em>Redis</em></strong> 最基本的数据类型，一个 <strong><em>Redis</em></strong> 中字符串 <strong><em>value</em></strong> 最多可以是 512M。</p><h3><a name='header-n211' class='md-header-anchor '></a>4.2.2 常用命令</h3><blockquote><p><code>set &lt;key&gt;&lt;value&gt;</code>：添加键值对</p><p><code>get &lt;key&gt;</code>：查询对应键值</p><p><code>append &lt;key&gt;&lt;value&gt;</code>：将给定的 <strong><em>&lt;value&gt;</em></strong> 追加到原值的末尾</p><p><code>strlen &lt;key&gt;</code>：获得值的长度</p><p><code>setnx &lt;key&gt;&lt;value&gt;</code>：只有在 <strong><em>key</em></strong> 不存在时，设置 <strong><em>key</em></strong> 的值</p><p><code>incr &lt;key&gt;</code>：将 <strong><em>key</em></strong> 中储存的数字值增 1，只能对数字值操作，如果为空，新增值为 1（<strong><u>具有原子性</u></strong>）</p><p><code>decr &lt;key&gt;</code>：将 <strong><em>key</em></strong> 中储存的数字值减 1，只能对数字值操作，如果为空，新增值为 -1</p><p><code>incrby/decrby &lt;key&gt;&lt;步长&gt;</code>：将 <strong><em>key</em></strong> 中储存的数字值增减。自定义步长</p><p><code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;</code> ：同时设置一个或多个 <strong><em>key-value</em></strong> 对 </p><p><code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt;...</code>：同时获取一个或多个 <strong><em>value</em></strong> </p><p><code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;...</code>：同时设置一个或多个 <strong><em>key-value</em></strong> 对，当且仅当所有给定 <strong><em>key</em></strong> 都不存在<span>	</span></p><p><code>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code>：获得值的范围</p><p><code>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code>：用 <strong><em>&lt;value&gt;</em></strong> 覆写 <strong><em>&lt;key&gt;</em></strong> 所储存的字符串值</p><p><code>setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code>：设置键值的同时，设置过期时间，单位秒。</p><p><code>getset &lt;key&gt;&lt;value&gt;</code>：以新换旧，设置了新值同时获得旧值。</p></blockquote><p><strong>原子性</strong></p><blockquote><p>所谓 <strong>原子</strong> 操作是指不会被线程调度机制打断的操作；</p><p>这种操作一旦开始，就一直运行到结束，中间不会有任何 <strong><em>context switch</em></strong> （切换到另一个线程）。</p><ul><li>在单线程中， 能够在单条指令中完成的操作都可以认为是&quot;原子操作&quot;，因为中断只能发生于指令之间。</li><li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</li></ul><p><strong><em>Redis</em></strong> 单命令的原子性主要得益于 <strong><em>Redis</em></strong> 的单线程。</p></blockquote><p><strong>数据结构</strong></p><p>内部结构实现上类似于 <strong><em>Java</em></strong> 的 <strong><em>ArrayList</em></strong>，采用预分配冗余空间的方式来减少内存的频繁分配.</p><p><img src='https://img-blog.csdnimg.cn/81c59230a12c4c94b99286c3c7d3aa42.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h2><a name='header-n242' class='md-header-anchor '></a>4.3 列表（List）</h2><p><strong><em>Redis</em></strong> 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><p><img src='https://img-blog.csdnimg.cn/4b2a2c48d65f438bb4e2dbd4ca546ce1.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><blockquote><p><code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....</code>： 从左边/右边插入一个或多个值。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n248" mdtype="fences">lpush k1 v1 v2 v3
lrange k1 0 -1
输出：v3 v2 v1

rpush k1 v1 v2 v3
rrange k1 0 -1
输出：v1 v2 v3
</pre><p><code>lpop/rpop &lt;key&gt;</code>：从左边/右边吐出一个值。值在键在，值光键亡。</p><p><code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code>：从 <strong><em>&lt;key1&gt;</em></strong> 列表右边吐出一个值，插到 <strong><em>&lt;key2&gt;</em></strong> 列表左边。</p><p><code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code>：按照索引下标获得元素（从左到右）</p><p><code>lrange mylist 0 -1  0</code>：左边第一个，-1右边第一个，（0 -1表示获取所有）</p><p><code>lindex &lt;key&gt;&lt;index&gt;</code>：按照索引下标获得元素（从左到右）</p><p><code>llen &lt;key&gt;</code>：获得列表长度  </p><p><code>linsert &lt;key&gt; before/after &lt;value&gt;&lt;newvalue&gt;</code>：在 <strong><em>&lt;value&gt;</em></strong> 的前面/后面插入 <strong><em>&lt;newvalue&gt;</em></strong> 插入值</p><p><code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code>：从左边删除 <strong><em>n</em></strong> 个 <strong><em>value</em></strong>（从左到右）</p><p><code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code>：将列表 <strong><em>key</em></strong> 下标为 <strong><em>index</em></strong> 的值替换成 <strong><em>value</em></strong></p></blockquote><p><strong>数据结构</strong></p><blockquote><p><strong><em>List</em></strong> 的数据结构为快速链表 <strong><em>quickList</em></strong>。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <strong><em>ziplist</em></strong>，也即是压缩列表。</p><p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p><p>当数据量比较多的时候才会改成 <strong><em>quicklist</em></strong>。</p><p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 <strong><em>int</em></strong> 类型的数据，结构上还需要两个额外的指针 <strong><em>prev</em></strong> 和 <strong><em>next</em></strong>。</p><p><strong><em>Redis</em></strong> 将链表和 <strong><em>ziplist</em></strong> 结合起来组成了 <strong><em>quicklist</em></strong>。也就是将多个 <strong><em>ziplist</em></strong> 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p></blockquote><p><img src='https://img-blog.csdnimg.cn/d57119fe6172435eaa41750e4d6e9aa6.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><h2><a name='header-n267' class='md-header-anchor '></a>4.4 Set（集合）</h2><p><strong><em>Set</em></strong> 对外提供的功能与 <strong><em>List</em></strong> 类似列表的功能，特殊之处在于 <strong><em>Set</em></strong> 是可以 <strong><u>自动排重</u></strong> 的，当需要存储一个列表数据，又不希望出现重复数据时，<strong><em>Set</em></strong> 是一个很好的选择，并且 <strong><em>Set</em></strong> 提供了判断某个成员是否在一个 <strong><em>Set</em></strong> 集合内的重要接口，这个也是 <strong><em>List</em></strong> 所不能提供的。</p><p><strong><em>Redis</em></strong> 的 <strong><em>Set</em></strong> 是 <strong><em>String</em></strong> 类型的无序集合。它底层其实是一个 <strong><em>value</em></strong> 为 <strong><em>null</em></strong> 的 <strong><em>hash</em></strong> 表，所以添加，删除，查找的复杂度都是 <strong><em>O(1)</em></strong>。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是 <strong><em>O(1)</em></strong>，数据增加，查找数据的时间不变。</p><blockquote><p><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .....</code>：将一个或多个 <strong><em>member</em></strong> 元素加入到集合 <strong><em>key</em></strong> 中，已经存在的 <strong><em>member</em></strong> 元素将被忽略</p><p><code>smembers &lt;key&gt;</code>：取出该集合的所有值。</p><p><code>sismember &lt;key&gt;&lt;value&gt;</code>：判断集合 <strong><em>&lt;key&gt;</em></strong> 是否为含有该 <strong><em>&lt;value&gt;</em></strong> 值，有返回 1，没有返回 0</p><p><code>scard&lt;key&gt;</code>：返回该集合的元素个数。</p><p><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....</code>：删除集合中的某个元素</p><p><code>spop &lt;key&gt;</code>：随机从该集合中吐出一个值</p><p><code>srandmember &lt;key&gt;&lt;n&gt;</code>：随机从该集合中取出 <strong><em>n</em></strong> 个值，不会从集合中删除 </p><p><code>smove &lt;source&gt;&lt;destination&gt;value</code>：把集合中一个值从一个集合移动到另一个集合</p><p><code>sinter &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的交集元素</p><p><code>sunion &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的并集元素</p><p><code>sdiff &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的差集元素（<strong><em>key1</em></strong> 中的，不包含 <strong><em>key2</em></strong> 中的）</p></blockquote><p><strong>数据结构</strong></p><p><strong><em>Set</em></strong> 数据结构是字典，字典是用哈希表实现的。</p><h2><a name='header-n285' class='md-header-anchor '></a>4.5 Hash（哈希）</h2><p><strong><em>Redis hash</em></strong> 是一个键值对集合。</p><p><strong><em>Redis hash</em></strong> 是一个 <strong><em>String</em></strong> 类型的 <strong><em>field</em></strong> 和 <strong><em>value</em></strong> 的映射表，<strong><em>hash</em></strong> 特别适合用于存储对象。</p><p>&nbsp;</p><blockquote><p><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：给 <strong><em>&lt;key&gt;</em></strong> 集合中的 <strong><em>&lt;field&gt;</em></strong> 键赋值 <strong><em>&lt;value&gt;</em></strong></p><p><code>hget &lt;key1&gt;&lt;field&gt;</code>：从 <strong><em>&lt;key1&gt;</em></strong> 集合 <strong><em>&lt;field&gt;</em></strong> 取出 <strong><em>value</em></strong> </p><p><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...</code>： 批量设置 <strong><em>hash</em></strong> 的值</p><p><code>hexists &lt;key1&gt;&lt;field&gt;</code>：查看哈希表 <strong><em>key</em></strong> 中，给定域 <strong><em>field</em></strong> 是否存在</p><p><code>hkeys &lt;key&gt;</code>：列出该 <strong><em>hash</em></strong> 集合的所有 <strong><em>field</em></strong></p><p><code>hvals &lt;key&gt;</code>：列出该 <strong><em>hash</em></strong> 集合的所有 <strong><em>value</em></strong></p><p><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;</code>：为哈希表 <strong><em>key</em></strong> 中的域 <strong><em>field</em></strong> 的值加上增量 1  -1</p><p><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：将哈希表 <strong><em>key</em></strong> 中的域 <strong><em>field</em></strong> 的值设置为 <strong><em>value</em></strong> ，当且仅当域 <strong><em>field</em></strong> 不存在<span>	</span></p></blockquote><p><strong>数据结构</strong></p><p><strong><em>Hash</em></strong> 类型对应的数据结构是两种：<strong><em>ziplist</em></strong>（压缩列表），<strong><em>hashtable</em></strong>（哈希表）。</p><p>当 <strong><em>field-value</em></strong> 长度较短且个数较少时，使用 <strong><em>ziplist</em></strong>，否则使用 <strong><em>hashtable</em></strong>。</p><p>&nbsp;</p><h2><a name='header-n302' class='md-header-anchor '></a>4.6 Zset（有序集合）</h2><p><strong><em>Redis</em></strong> 有序集合 <strong><em>zset</em></strong> 与普通集合 <strong><em>set</em></strong> 非常相似，是一个没有重复元素的字符串集合。</p><p>不同之处是有序集合的每个成员都关联了一个评分（<strong><em>score</em></strong>）,这个评分（<strong><em>score</em></strong>）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的。</p><p>因为元素是有序的，所以可以很快的根据评分（<strong><em>score</em></strong>）或者次序（<strong><em>position</em></strong>）来获取一个范围的元素。</p><p>访问有序集合的中间元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。</p><p><strong>常用操作</strong></p><blockquote><p><code>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…</code>：将一个或多个 <strong><em>member</em></strong> 元素及其 <strong><em>score</em></strong> 值加入到有序集 <strong><em>key</em></strong> 当中</p><p><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]</code>：返回有序集 <strong><em>key</em></strong> 中，下标在 <strong><em>&lt;start&gt;&lt;stop&gt;</em></strong> 之间的元素</p><p>当带 <strong><em>WITHSCORES</em></strong>，可以让分数一起和值返回到结果集</p><p><code>zrangebyscore key min max [withscores] [limit offset count]</code>：返回有序集 <strong><em>key</em></strong> 中，所有 <strong><em>score</em></strong> 值介于 <strong><em>min</em></strong> 和 <strong><em>max</em></strong> 之间（包括等于 <strong><em>min</em></strong> 或 <strong><em>max</em></strong> ）的成员。有序集成员按 <strong><em>score</em></strong> 值递增（从小到大）次序排列。</p><p><code>zrevrangebyscore key max min [withscores] [limit offset count]</code>：同上，改为从大到小排列</p><p><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</code>：为元素的 <strong><em>score</em></strong> 加上增量</p><p><code>zrem &lt;key&gt;&lt;value&gt;</code>：删除该集合下，指定值的元素</p><p><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code>：统计该集合，分数区间内的元素个数 </p><p><code>zrank &lt;key&gt;&lt;value&gt;</code>：返回该值在集合中的排名，从 0 开始。</p></blockquote><p><strong>数据结构</strong></p><p><strong><em>SortedSet（zset）</em></strong>是 <strong><em>Redis</em></strong> 提供的一个非常特别的数据结构，一方面它等价于 <strong><em>Java</em></strong> 的数据结构 <strong><em>Map&lt;String, Double&gt;</em></strong>，可以给每一个元素 <strong><em>value</em></strong> 赋予一个权重 <strong><em>score</em></strong>，另一方面它又类似于 <strong><em>TreeSet</em></strong>，内部的元素会按照权重 <strong><em>score</em></strong> 进行排序，可以得到每个元素的名次，还可以通过 <strong><em>score</em></strong> 的范围来获取元素的列表。</p><p><strong><em>zset</em></strong> 底层使用了两个数据结构</p><ul><li><strong><em>hash</em></strong>，<strong><em>hash</em></strong> 的作用就是关联元素 <strong><em>value</em></strong> 和权重 <strong><em>score</em></strong>，保障元素 <strong><em>value</em></strong> 的唯一性，可以通过元素 <strong><em>value</em></strong> 找到相应的 <strong><em>score</em></strong> 值</li><li>跳跃表，跳跃表的目的在于给元素 <strong><em>value</em></strong> 排序，根据 <strong><em>score</em></strong> 的范围获取元素列表</li></ul><p><strong>跳跃表</strong></p><blockquote><ul><li>简介：</li></ul><p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p><ul><li>使用：</li></ul><p>对比有序链表和跳跃表，从链表中查询出51：</p><p>（1）  有序链表</p><p><img src='https://img-blog.csdnimg.cn/0549496399db4fbe8fc21b1d6f8f9154.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p><p>（2）  跳跃表</p><p><img src='https://img-blog.csdnimg.cn/a1f719feb86442cc9ab45cf16c22a4e2.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>从第2层开始，1节点比51节点小，向后比较。</p><p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</p><p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p><p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p><p>从此可以看出跳跃表比有序链表效率要高</p></blockquote><h1><a name='header-n346' class='md-header-anchor '></a>5. Redis6新数据结构</h1><h2><a name='header-n347' class='md-header-anchor '></a>5.1 Bitmaps</h2><blockquote><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图</p><p><img src='https://img-blog.csdnimg.cn/3763313980c145289bef1bc18ee635ae.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>合理地使用操作位能够有效地提高内存使用率和开发效率。</p><p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p><p>（1）    Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</p><p>（2）    Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p><p><img src='https://img-blog.csdnimg.cn/d660231430314443b9a90aca97960149.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></blockquote><p><strong>常用命令</strong></p><blockquote><p><code>setbit&lt;key&gt;&lt;offset&gt;&lt;value&gt;：</code>设置Bitmaps中某个偏移量的值（0或1）*offset:偏移量从0开始</p><p>实例</p><p>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。</p><p>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图：</p><p><img src='https://img-blog.csdnimg.cn/1cbe21aeb3ca41ec8b10948341fd0b2b.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps</p><p>注：</p><p>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。</p><p>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</p></blockquote><blockquote><p><code>getbit&lt;key&gt;&lt;offset&gt;：</code>获取Bitmaps中某个偏移量的值</p><p>实例</p><p>获取id=8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过：</p><p>注：因为100根本不存在，所以也是返回0</p></blockquote><blockquote><p>bitcount</p><p>统计<strong>字符串</strong>被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。</p><p><code>bitcount&lt;key&gt;[start end]：</code>统计字符串从start字节到end字节比特值为1的数量</p><p>实例</p><p>计算2022-11-06这天的独立访问用户数量</p><p>start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数，
对应的用户id是11， 15， 19。</p><p>注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。</p></blockquote><blockquote><p><code>bitop 
and(or/not/xor) &lt;destkey&gt; [key…]：</code>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</p><p>实例</p><p>2020-11-04 日访问网站的userid=1,2,5,9。</p><p>setbit unique:users:20201104 1 1</p><p>setbit unique:users:20201104 2 1</p><p>setbit unique:users:20201104 5 1</p><p>setbit unique:users:20201104 9 1</p><p>&nbsp;</p><p>2020-11-03 日访问网站的userid=0,1,4,9。</p><p>setbit unique:users:20201103 0 1</p><p>setbit unique:users:20201103 1 1</p><p>setbit unique:users:20201103 4 1</p><p>setbit unique:users:20201103 9 1</p><p> </p><p>计算出两天都访问过网站的用户数量</p><p>bitop and unique:users:and:20201104_03 unique:users:20201103unique:users:20201104</p><p>&nbsp;</p><p><img src='https://img-blog.csdnimg.cn/58799e4482214950908e21ef9d4df2cc.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集</p><p><img src='https://img-blog.csdnimg.cn/421556395b0545f19a0e002c328a8b0b.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></blockquote><h2><a name='header-n401' class='md-header-anchor '></a>5.2 Bitmaps与set对比</h2><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p><figure><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比</th><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td>数据   类型</td><td>每个用户id占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合   类型</td><td>64位</td><td>50000000</td><td>64位*50000000 = 400MB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table></figure><p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间，
尤其是随着时间推移节省的内存还是非常可观的</p><figure><table><thead><tr><th>set和Bitmaps存储独立用户空间对比</th><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td>数据类型</td><td>一天</td><td>一个月</td><td>一年</td></tr><tr><td>集合类型</td><td>400MB</td><td>12GB</td><td>144GB</td></tr><tr><td>Bitmaps</td><td>12.5MB</td><td>375MB</td><td>4.5GB</td></tr></tbody></table></figure><p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少，
例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了，
因为基本上大部分位都是0。</p><figure><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比（独立用户比较少）</th><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td>数据类型</td><td>每个userid占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合类型</td><td>64位</td><td>100000</td><td>64位*100000 = 800KB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table></figure><h2><a name='header-n468' class='md-header-anchor '></a>5.3 HyperLogLog</h2><blockquote><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。</p><p>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p><p>解决基数问题有很多种方案：</p><p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p><p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p><p>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>什么是基数?</p><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p></blockquote><p><strong>常用命令</strong></p><blockquote><p><code>pfadd &lt;key&gt;&lt; element&gt; [element ...] ：</code>添加指定元素到 HyperLogLog 中</p><p>将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。</p><p><code>pfcount&lt;key&gt; [key ...] ：</code>计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</p><p><code>pfmerge&lt;destkey&gt;&lt;sourcekey&gt;
[sourcekey ...] ：</code>将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</p></blockquote><h2><a name='header-n488' class='md-header-anchor '></a>5.4 Geospatial</h2><blockquote><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p></blockquote><p><strong>常用命令</strong></p><blockquote><p><code>geoadd&lt;key&gt;&lt; longitude&gt;&lt;latitude&gt;&lt;member&gt;
[longitude latitude member...]</code> 添加地理位置（经度，纬度，名称）</p><p>geoadd china:city 121.47 31.23 shanghai</p><p>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing</p><p>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。</p><p>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。</p><p>当坐标位置超出指定范围时，该命令将会返回一个错误。</p><p>已经添加的数据，是无法再次往里面添加的。</p></blockquote><blockquote><p><code>geopos 
&lt;key&gt;&lt;member&gt; [member...] 
：</code>获得指定地区的坐标值</p><p><code>geodist&lt;key&gt;&lt;member1&gt;&lt;member2&gt;  [m|km|ft|mi ] :</code>获取两个位置之间的直线距离</p><p>单位：</p><p>m 表示单位为米[默认值]。</p><p>km 表示单位为千米。</p><p>mi 表示单位为英里。</p><p>ft 表示单位为英尺。</p><p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</p><p><code>georadius&lt;key&gt;&lt; longitude&gt;&lt;latitude&gt;radius  m|km|ft|mi ：</code>以给定的经纬度为中心，找出某一半径内的元素</p></blockquote><h1><a name='header-n510' class='md-header-anchor '></a>6. Redis的发布与订阅</h1><p><strong><em>Redis</em></strong> 发布订阅（ <strong><em>pub/sub</em></strong> ）是一种消息通信模式：发送者（ <strong><em>pub</em></strong> ）发送消息，订阅者（ <strong><em>sub</em></strong> ）接收消息。</p><p><strong><em>Redis</em></strong> 客户端可以订阅任意数量的频道。</p><ol start='' ><li>客户端可以订阅频道</li></ol><p><img src='https://img-blog.csdnimg.cn/4ebe50f0cad743daa5a2639c58566ec2.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><ol start='2' ><li>当给这个频道发布消息后，消息就会发送给订阅的客户端</li></ol><p><img src='https://img-blog.csdnimg.cn/c8e5727bc0b0435a96b920922c03f52b.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><blockquote><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n523" mdtype="fences">subscribe channel # 订阅频道

publish channel hello # 频道发送信息
</pre></blockquote><h1><a name='header-n524' class='md-header-anchor '></a>7. 事务和锁机制</h1><blockquote><p><strong><em>Redis</em></strong> 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p><strong><em>Redis</em></strong> 事务的主要作用就是串联多个命令防止别的命令插队。</p></blockquote><p>&nbsp;</p><h2><a name='header-n529' class='md-header-anchor '></a>7.1 <em>Multi</em>、<em>Exec</em>、<em>Discard</em></h2><blockquote><p><strong><em>Multi</em></strong></p><p><strong><em>Exec</em></strong></p><p><strong><em>Discard</em></strong><span>	</span></p><p>从输入 <strong><em>Multi</em></strong> 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 <strong><em>Exec</em></strong> 后，<strong><em>Redis</em></strong> 会将之前的命令队列中的命令依次执行。</p><p>组队的过程中可以通过 <strong><em>Discard</em></strong> 来放弃组队。 </p></blockquote><ul><li><p>组队成功，提交成功</p><p><img src='https://img-blog.csdnimg.cn/9b6d8788432d48e7b73994f260d2933c.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></li><li><p>放弃组队</p><p><img src='https://img-blog.csdnimg.cn/d838519de86149719650576960c0e18c.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>组队中有命令错误，不会执行</p><p><img src='https://img-blog.csdnimg.cn/cb9d6b3f451b4e4ab23f39fb73d6f3aa.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></li><li><p>组队中不报错，执行时报错</p><p><img src='https://img-blog.csdnimg.cn/db1778b429f845a88bcb29bbf05f6c7b.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></li></ul><blockquote><p>当组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p><p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p></blockquote><p>&nbsp;</p><h2><a name='header-n552' class='md-header-anchor '></a>7.2 悲观锁</h2><p>悲观锁（<strong><em>Pessimistic Lock</em></strong>），即每次去拿数据的时候都认为有其他线程会修改，所以每次在拿数据的时候都会上锁，这样其他线程想要拿到这个数据就会被 <strong><em>block</em></strong> 直到成功拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。（效率低）</p><p>&nbsp;</p><h2><a name='header-n555' class='md-header-anchor '></a>7.3 乐观锁</h2><p>乐观锁（<strong><em>Optimistic Lock</em></strong>），即每次去拿数据的时候都认为其他线程不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间有没有其他线程去更新这个数据，可以使用版本号等机制。</p><p><strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。</p><p><strong><em>Redis</em></strong> 就是利用这种 <strong><em>check-and-set</em></strong> 机制实现事务的。</p><p>&nbsp;</p><h2><a name='header-n560' class='md-header-anchor '></a>7.4 <em>Watch、unwatch</em></h2><p>在执行 <strong><em>multi</em></strong> 之前，先执行 <strong><em>watch key1 [key2]</em></strong>，可以监视一个（或多个 ）<strong><em>key</em></strong> 。如果在事务执行之前这个 <strong><em>key</em></strong> 被其他命令所改动，那么事务将被打断。</p><p>取消 <strong><em>WATCH</em></strong> 命令对所有 <strong><em>key</em></strong> 的监视。如果在执行 <strong><em>WATCH</em></strong> 命令之后，<strong><em>EXEC</em></strong> 命令或 <strong><em>DISCARD</em></strong> 命令先被执行，那么就不需要再执行 <strong><em>UNWATCH</em></strong> 。</p><p><img src='https://img-blog.csdnimg.cn/62402741fa4c44489b8b5b3801fe19d1.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><img src='https://img-blog.csdnimg.cn/1c7cb496c0ae4b2fa820ebe6f0c8c20b.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h2><a name='header-n566' class='md-header-anchor '></a>7.5 事务三特性</h2><blockquote><ul><li><p>单独的隔离操作 </p><p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p></li><li><p>没有隔离级别的概念 </p><p>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p></li><li><p>不保证原子性 </p><p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 。</p></li></ul></blockquote><p>&nbsp;</p><h2><a name='header-n579' class='md-header-anchor '></a>7.6 Redis事务秒杀案例</h2><p><strong>工具ab模拟测试</strong></p><blockquote><p>yum install httpd-tools</p><p>vim
postfile 模拟表单提交参数,以&amp;符号结尾;存放当前目录。</p><p>内容：prodid=0101&amp;</p><p>ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded <a href='http://192.168.2.115:8081/Seckill/doseckill' target='_blank' class='url'>http://192.168.2.115:8081/Seckill/doseckill</a></p></blockquote><p><img src='https://img-blog.csdnimg.cn/5e8d15d6b45c41668470358494bdfc0f.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>第一版：简单版</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n588" mdtype="fences" style="break-inside: unset;">//秒杀过程
public static boolean doSecKill(String uid,String prodid) throws Exception{
    //1.uid和prodid非空判断
    if(uid==null||prodid==null){
        return false;
    }
    //2.连接redis
    Jedis jedis = new Jedis("192.168.22.138",6379);
    //通过连接池得到jedis对象
    //JedisPool jedisPoolInstance = JedisPoolUtil.getJedisPoolInstance();
    //Jedis jedis = jedisPoolInstance.getResource();
    //3.拼接key
    //3.1库存key
    String kcKey = "sk:" + prodid + ":qt";
    //3.2秒杀成功用户key
    String userKey = "sk:" + prodid + ":user";
    
    //监视库存
    jedis.watch(kcKey);
    
    //4.获取库存，如果库存为null，则秒杀还未开始
    String kc = jedis.get(kcKey);
    if(kc==null){
        System.out.println("秒杀未开始，请等待...")；
        jedis.close();
        return false;
    }
    //5.判断用户是否重复秒杀操作
    if(jedis.sismember(userKey,uid)){
        System.out.println("秒杀成功，不能重复秒杀");
        jedis.close();
        return false;
    }
    //6.判断如果商品数量，库存数量小于1，则秒杀结束
    if(Integer.parseInt(kc)&lt;=0){
        System.out.println("秒杀结束！");
        jedis.close();
        return false;
    }
    //7.秒杀过程
    
    //使用事务
    Transaction multi = jedis.multi();
    //组队操作
    multi.decr(kcKey);
    multi.sadd(userKey,uid);
    //执行
    List&lt;Object&gt; results = multi.exex();
    if(results==null||results.size()==0){
        System.out.println("秒杀失败");
        jedis.close();
        return false;
    }
    
    //7.1库存-1
    //jedis.decr(kcKey);
    //7.2把秒杀成功用户添加到清单里面
    //jedis.sadd(userKey,uid);
    System.out.println("秒杀成功！");
    jedis.close();
    return true;
}
</pre><p>&nbsp;</p><p>第二版：加事务-乐观锁(解决超卖),但出现遗留库存和连接超时</p><p><img src='https://img-blog.csdnimg.cn/93c5853ab2f7409d847f17aa8291fb2c.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /><img src='https://img-blog.csdnimg.cn/ffe9a335cb59458d8c402580eac34a4a.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n592" mdtype="fences" style="break-inside: unset;">//增加乐观锁
jedis.watch(qtkey);

//3.判断库存
String qtkeystr = jedis.get(qtkey);
if(qtkeystr==null || "".equals(qtkeystr.trim())) {
    System.out.println("未初始化库存");
    jedis.close();
    return false ;
}

int qt = Integer.parseInt(qtkeystr);
if(qt&lt;=0) {
    System.err.println("已经秒光");
    jedis.close();
    return false;
}

//增加事务
Transaction multi = jedis.multi();

//4.减少库存
//jedis.decr(qtkey);
multi.decr(qtkey);

//5.加人
//jedis.sadd(usrkey, uid);
multi.sadd(usrkey, uid);

//执行事务
List&lt;Object&gt; list = multi.exec();

//判断事务提交是否失败
if(list==null || list.size()==0) {
    System.out.println("秒杀失败");
    jedis.close();
    return false;
}
System.err.println("秒杀成功");
jedis.close();
</pre><p>&nbsp;</p><p>第三版：连接池解决超时问题</p><p><code>单例模式双端检锁</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n596" mdtype="fences" style="break-inside: unset;">public class JedisPoolUtil{
    private static volatile JedisPool jedisPool = null;
    private JedisPoolUtil(){
        
    }
    public static JedisPool getJedisPoolInstance(){
        if(null==jedisPool){
            synchronized(JedisPoolUtil.class){
                if(null==jedisPool){
                    JedisPoolConfig poolConfig = new JedisPoolConfig();
                    poolConfig.setMaxTotal(200);
                    poolConfig.setMaxIdle(32);
                    poolConfig.setMaxWaitMillis(100*1000);
                    poolConfig.setBlockWhenExhausted(true);
                    poolConfig.setTestOnBorrow(true);
                    jedisPool = new JedisPool(poolConfig,"192.168.128.182",6379,60000);
                }
            }
        }
        return jedisPool;
    }
    
    
    public static void release(JedisPool jedisPool,Jedis jedis){
       if(null!=jedis){
           jedisPool.returnResource(jedis);
       }
    }
    
}
</pre><blockquote><p>l  链接池参数</p><p>MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</p><p>maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</p><p>MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；</p><p>testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；</p></blockquote><p>第四版：解决乐观锁造成的库存遗留问题，LUA脚本 </p><blockquote><p>Lua 是一个小巧的<a href='http://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80'>脚本语言</a>，Lua脚本可以很容易的被C/C++
代码调用，也可以反过来调用C/C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。</p></blockquote><blockquote><p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。</p><p>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。</p><p>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。</p><p>利用lua脚本淘汰用户，解决超卖问题。</p><p>redis 2.6版本以后，通过lua脚本解决<strong>争抢问题</strong>，实际上是<strong>redis</strong> <strong>利用其单线程的特性，用任务队列的方式解决多任务并发问题</strong>。</p></blockquote><p><img src='https://img-blog.csdnimg.cn/5c4f9df47f464b60b37a60e5a0390da7.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="lua" contenteditable="false" cid="n613" mdtype="fences" style="break-inside: unset;">local userid=KEYS[1]; 
local prodid=KEYS[2];
local qtkey="sk:"..prodid..":qt";
local usersKey="sk:"..prodid.":usr'; 
local userExists=redis.call("sismember",usersKey,userid);
if tonumber(userExists)==1 then 
    return 2;
end
local num= redis.call("get" ,qtkey);
if tonumber(num)&lt;=0 then 
    return 0; 
else 
    redis.call("decr",qtkey);
    redis.call("sadd",usersKey,userid);
end
return 1;
</pre><p>&nbsp;</p><h1><a name='header-n615' class='md-header-anchor '></a>8. 持久化</h1><h2><a name='header-n616' class='md-header-anchor '></a>8.1 RDB</h2><p>在指定的<strong>时间间隔</strong>内将内存中的<strong>数据集快照</strong>写入磁盘， 即 <strong><em>Snapshot</em></strong> 快照，恢复时是将快照文件直接读到内存里。</p><p><img src='https://img-blog.csdnimg.cn/8bc7b02befc042c2b8d9941b6b9b6b1f.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>Redis</em></strong> 会单独创建一个子进程（<strong><em>fork</em></strong>）来进行持久化。</p><p>先将数据写入到一个临时文件中，待持久化过程完成后，再将这个临时文件内容覆盖到 <strong><em>dump.rdb</em></strong>。 </p><p>整个过程中，主进程是不进行任何 <strong><em>IO</em></strong> 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 <strong><em>RDB</em></strong> 方式要比 <strong><em>AOF</em></strong> 方式更加的高效。</p><p><strong><em>RDB</em> 的缺点是最后一次持久化后的数据可能丢失</strong>。</p><p> </p><h3><a name='header-n624' class='md-header-anchor '></a>8.1.2 Fork</h3><ul><li>作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</li><li>在 <strong><em>Linux</em></strong> 程序中，<strong><em>fork()</em></strong> 会产生一个和父进程完全相同的子进程，但子进程在此后多会 <strong><em>exec</em></strong> 系统调用，出于效率考虑，<strong><em>Linux</em></strong> 中引入了 <strong>写时复制技术</strong></li><li><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</li></ul><p><img src='https://img-blog.csdnimg.cn/9f29801571284106b9ea66cf59d8629a.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><h3><a name='header-n633' class='md-header-anchor '></a>8.1.3 配置</h3><blockquote><p><strong><em>dump</em> 文件名字</strong></p><p>在 <strong><em>redis.conf</em></strong> 中配置文件名称，默认为 <strong><em>dump.rdb</em></strong>。</p><p><img src='https://img-blog.csdnimg.cn/8e00ba8ace91430ca4990a51e1ad8e2e.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>dump</em> 保存位置</strong></p><p><strong><em>rdb</em></strong> 文件的保存路径可以修改。默认为 <strong><em>Redis</em></strong> 启动时命令行所在的目录下。</p><p><img src='https://img-blog.csdnimg.cn/124d92e01cbc4ba1887f6ccb2bdab454.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>stop-writes-on-bgsave-error</em></strong></p><p>即当 <strong><em>redis</em></strong> 无法写入磁盘，关闭 <strong><em>redis</em></strong> 的写入操作。推荐<strong><em>yes</em></strong>。</p><p><img src='https://img-blog.csdnimg.cn/4b80348480fd4e4ca2f79dc7d8874582.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>rdbcompression</em></strong></p><p>持久化的文件是否进行压缩存储。</p><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。</p><p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p><p><img src='https://img-blog.csdnimg.cn/003a7f6a9e4142939bc110cd7ba7f9a2.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>rdbchecksum</em></strong></p><p>完整性的检查，即数据是否完整性、准确性。</p><p>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，</p><p>但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能，推荐yes.</p><p><img src='https://img-blog.csdnimg.cn/7bf31d1403aa48e5a78c2ee146f7eae5.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>save</em></strong></p><p>表示写操作的次数。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n656" mdtype="fences">格式：save 秒 写操作次数
</pre><p><img src='https://img-blog.csdnimg.cn/e815ac15bd69448fbc044b6db5cff0e4.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></blockquote><h3><a name='header-n658' class='md-header-anchor '></a>8.1.4 命令</h3><blockquote><p>配置文件中默认的快照配置：</p><p><img src='https://img-blog.csdnimg.cn/e94e4200d6b04e388011ea8799faa910.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>save VS bgsave</strong></p><p>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。</p><p><strong>bgsave</strong>：<strong><em>Redis</em></strong>会在后台异步进行快照操作，<strong>快照同时还可以响应客户端请求</strong>。</p><p>可以通过lastsave 命令获取最后一次成功执行快照的时间。</p><p>&nbsp;</p><p><strong>flushall</strong></p><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p><p>&nbsp;</p><p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，</p><p>默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。</p><p>禁用：不设置save指令，或者给save传入空字符串。</p></blockquote><h3><a name='header-n674' class='md-header-anchor '></a>8.1.5 rdb备份</h3><blockquote><p>先通过config get dir  查询rdb文件的目录 </p><p>将*.rdb的文件拷贝到别的地方</p><p>rdb的恢复：</p><ul><li>关闭Redis</li><li>先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb</li><li>启动Redis, 备份数据会直接加载</li></ul><p><strong>停止：</strong></p><p>动态停止RDB：redis-cli config set
save &quot;&quot;#save后给空值，表示禁用保存策略。</p></blockquote><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="bash" contenteditable="false" cid="n688" mdtype="fences">cp dumb.rdb d.rdb
ps -ef | grep  redis
kill -9 3256
rm -f dump.rdb
mv d.rdb dump.rdb
redis-server /etc/redis.conf
keys *
</pre><h3><a name='header-n689' class='md-header-anchor '></a>8.1.6 优点</h3><ul><li>适合大规模的数据恢复；</li><li>对数据完整性和一致性要求不高更适合使用；</li><li>节省磁盘空间；</li><li>恢复速度快。</li></ul><h3><a name='header-n699' class='md-header-anchor '></a>8.1.7 缺点</h3><ul><li><strong><em>Fork</em></strong> 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑；</li><li>虽然 <strong><em>Redis</em></strong> 在 <strong><em>fork</em></strong> 时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能；</li><li>在备份周期在一定间隔时间做一次备份，所以如果 <strong><em>Redis</em></strong> 意外 <strong><em>down</em></strong> 掉的话，就会丢失最后一次快照后的所有修改。</li></ul><p>&nbsp;</p><h2><a name='header-n708' class='md-header-anchor '></a>8.2 AOF</h2><p>以日志的形式来记录每个写操作（增量保存），将 <strong><em>Redis</em></strong> 执行过的所有写指令记录下来（读操作不记录）， <u>只许追加文件但不可以改写文件</u>，<strong><em>Redis</em></strong> 启动之初会读取该文件重新构建数据，换言之，如果 <strong><em>Redis</em></strong> 重启就会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p><strong>执行流程</strong></p><ul><li>客户端的请求写命令会被 <strong><em>append</em></strong> 追加到 <strong><em>AOF</em></strong> 缓冲区内；</li><li><strong><em>AOF</em></strong> 缓冲区根据 <strong><em>AOF</em></strong> 持久化策略 <code>[always,everysec,no]</code> 将操作 <strong><em>sync</em></strong> 同步到磁盘的 <strong><em>AOF</em></strong> 文件中；</li><li><strong><em>AOF</em></strong> 文件大小超过重写策略或手动重写时，会对 <strong><em>AOF</em></strong> 文件 <strong><em>Rewrite</em></strong> 重写，压缩 <strong><em>AOF</em></strong> 文件容量；</li><li><strong><em>Redis</em></strong> 服务重启时，会重新 <strong><em>load</em></strong> 加载 <strong><em>AOF</em></strong> 文件中的写操作达到数据恢复的目的。</li></ul><p><img src='https://img-blog.csdnimg.cn/312cbf46c5f24213855850e35ba1d500.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>AOF</em></strong> 和 <strong><em>RDB</em></strong> 同时开启时，系统默认读取 <strong><em>AOF</em></strong> 的数据（数据不会存在丢失）</p><h3><a name='header-n722' class='md-header-anchor '></a>8.2.1 配置</h3><blockquote><p><strong><em>AOF</em> 默认不开启</strong> </p><p><img src='https://img-blog.csdnimg.cn/b09d201529f94e4681d4c33257787caf.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong>文件名字</strong></p><p><img src='https://img-blog.csdnimg.cn/1b34f2fd92b747a499a4a453bb4617e5.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>AOF</em> 同步频率设置</strong></p><p><img src='https://img-blog.csdnimg.cn/778ea47c57a6495eb4872f0213f9ad07.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>appendfsync always</em></strong></p><p><span>	</span>始终同步，每次 <strong><em>Redis</em></strong> 的写入都会立刻记入日志；</p><p><span>	</span>性能较差但数据完整性比较好。</p><p><strong><em>appendfsync everysec</em></strong></p><p><span>	</span>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p><p><strong><em>appendfsync no</em></strong></p><p><span>	</span><strong><em>Redis</em></strong> 不主动进行同步，把同步时机交给操作系统。</p><p>&nbsp;</p><p><strong>AOF启动/修复/恢复</strong></p><p>l  AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p><p>l  正常恢复</p><ul><li>修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li><li>恢复：重启redis然后重新加载 </li></ul><p>l  异常恢复</p><ul><li>修改默认的appendonly no，改为yes</li><li>如遇到<strong><em>AOF</em></strong>文件损坏，通过<strong><em>/usr/local/bin/edis-check-aof--fix appendonly.aof</em></strong>进行恢复</li><li>备份被写坏的AOF文件</li><li>恢复：重启redis，然后重新加载</li></ul><p>&nbsp;</p><p><strong><em>Rewrite</em> 压缩</strong></p><p>当 <strong><em>AOF</em></strong> 文件的大小超过所设定的阈值时，<strong><em>Redis</em></strong> 就会启动 <strong><em>AOF</em></strong> 文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 <strong><em>bgrewriteaof</em></strong>。</p><p><strong>重写原理：</strong>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</p><p><img src='https://img-blog.csdnimg.cn/3dec233bd39b423ebca2e5b247c5e542.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></blockquote><blockquote><p>如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</p><p>如果 no-appendfsync-on-rewrite=no,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p><p><strong>触发机制：</strong></p><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p><p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。 </p><p>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）</p><p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。</p><p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,</p><p>如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。 </p><p><strong>重写流程：</strong></p><p>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</p><p>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。</p><p>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</p><p>（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</p><p>（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p><p><img src='https://img-blog.csdnimg.cn/0cd5dab01b5e4972b9c54b24154621dc.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p></blockquote><h3><a name='header-n782' class='md-header-anchor '></a>8.2.2 优点</h3><ul><li>备份机制更稳健，丢失数据概率更低；</li><li>可读的日志文本，通过操作 <strong><em>AOF</em></strong> 稳健，可以处理误操作。</li></ul><p>&nbsp;</p><h3><a name='header-n789' class='md-header-anchor '></a>8.2.3 缺点</h3><ul><li>比起 <strong><em>RDB</em></strong> 占用更多的磁盘空间；</li><li>恢复备份速度要慢；</li><li>每次读写都同步的话，有一定的性能压力；</li><li>存在个别 <strong><em>Bug</em></strong>，造成不能恢复。</li></ul><h2><a name='header-n799' class='md-header-anchor '></a>8.3 选择</h2><blockquote><p>官方推荐两个都启用。</p><p>如果对数据不敏感，可以选单独用 <strong><em>RDB</em></strong>。</p><p>不建议单独用 <strong><em>AOF</em></strong>，因为可能会出现 <strong><em>Bug</em></strong>。</p><p>如果只是做纯内存缓存，可以都不用。</p></blockquote><h2><a name='header-n805' class='md-header-anchor '></a>8.4 官方建议</h2><blockquote><p>l  RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。</p><p>l  AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.。</p><p>l  Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。</p><p>l  只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式。</p><p>l  同时开启两种持久化方式。</p><p>l  在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</p><p>l  RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ </p><p>l  建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p><p>l  性能建议：</p><p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</p><p>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。</p><p>代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</p><p>只要硬盘许可，应该尽量减少AOF
rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。</p><p>默认超过原大小100%大小时重写可以改到适当的数值。</p></blockquote><h1><a name='header-n821' class='md-header-anchor '></a>9. 主从复制</h1><p>主机数据更新后根据配置和策略， 自动同步到备机的 <strong><em>master/slaver</em></strong> 机制，<strong><em>Master</em></strong> 以写为主，<strong><em>Slaver</em></strong> 以读为主。</p><ol start='' ><li><img src='https://img-blog.csdnimg.cn/5129ce535d2a42e995577118b2d96646.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></li><li>读写分离，性能扩展</li><li>容灾快速恢复</li><li>一主多从！</li></ol><p>&nbsp;</p><h2><a name='header-n833' class='md-header-anchor '></a>9.1 搭建一主两从</h2><p><img src='https://img-blog.csdnimg.cn/c93c3ef2aab04414ab2b43862096e305.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><img src='https://img-blog.csdnimg.cn/b012734142a04567981e1c9d92b99193.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><blockquote><p>拷贝多个redis.conf文件include(写绝对路径)</p><p>开启daemonize yes</p><p>Pid文件名字pidfile</p><p>指定端口port</p><p>Log文件名字</p><p>dump.rdb名字dbfilename</p><p>Appendonly 关掉或者换名字</p></blockquote><ol start='' ><li>创建文件目录</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n847" mdtype="fences">/opt/etc
</pre><ol start='2' ><li>将 <strong><em>redis.conf</em></strong> 复制到当前目录</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n851" mdtype="fences">cp /etc/redis.conf /opt/etc/
</pre><ol start='3' ><li>创建 3 个 <strong><em>redis.conf</em></strong> 配置文件</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n855" mdtype="fences">redis6379.conf
redis6380.conf
redis6381.conf
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="bash" contenteditable="false" cid="n856" mdtype="fences" style="break-inside: unset;"># 填写以下内容
# redis6379.conf
include /opt/etc/redis.conf # 引入公共部分
pidfile /var/run/redis_6379.pid
port 6379
dbfilename dump6379.rdb

# redis6380.conf
include /opt/etc/redis.conf
pidfile /var/run/redis_6380.pid
port 6380
dbfilename dump6380.rdb

# redis6381.conf
include /opt/etc/redis.conf
pidfile /var/run/redis_6381.pid
port 6381
dbfilename dump6381.rdb
</pre><ol start='4' ><li>启动 3 台 <strong><em>redis</em></strong> 服务器</li></ol><p><img src='https://img-blog.csdnimg.cn/0e0603fd15304375a93f14726b3f97b7.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><ol start='5' ><li>查看三台主机运行情况</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n864" mdtype="fences">info replication
</pre><p><img src='https://img-blog.csdnimg.cn/470db935864b47f69e5b3c8a9e9b894e.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><ol start='6' ><li>配从不配主</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="bash" contenteditable="false" cid="n869" mdtype="fences">slaveof  &lt;ip&gt;&lt;port&gt;
# 成为某个实例的从服务器
</pre><p><img src='https://img-blog.csdnimg.cn/b153993d0ee64437a4b6386ab275ab7b.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><img src='https://img-blog.csdnimg.cn/261992a90f404e21b2ee063e968f3185.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><ol start='7' ><li>再次查看主机运行情况：<code>info replication</code></li></ol><p><img src='https://img-blog.csdnimg.cn/20add11380204200a8169cb2c5a7ebf1.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><ol start='8' ><li>成功搭建。</li></ol><blockquote><ul><li>在6380和6381上执行: slaveof 127.0.0.1 6379</li><li>在主机上写，在从机上可以读取数据，在从机上写数据报错。</li><li>主机挂掉，重启就行，一切如初。</li><li>从机重启需重设：slaveof
127.0.0.1 6379，也可以将配置增加到文件中。永久生效。</li></ul></blockquote><p>&nbsp;</p><h2><a name='header-n890' class='md-header-anchor '></a>9.2 一主二仆</h2><blockquote><p>主机 <strong><em>6379</em></strong>，从机 <strong><em>6380</em></strong> 和 <strong><em>6381</em></strong>。</p><ol start='' ><li>假设从机 <strong><em>6380</em></strong> 挂掉。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n896" mdtype="fences">当6380重启后，6380不再是6379的从机，而是作为新的master；
当再次把6380作为6379的从机加入后，从机会把数据从头到尾复制。
</pre><ol start='2' ><li>假设主机 <strong><em>6379</em></strong> 挂掉。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n900" mdtype="fences">6380和6381仍然是6379的从机，不会做任何事；
当6379重启后，既然是主服务器。
</pre></blockquote><p>&nbsp;</p><h2><a name='header-n902' class='md-header-anchor '></a>9.3 薪火相传</h2><p><img src='https://img-blog.csdnimg.cn/86aca77735ac472ab4540be78232713a.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>上一个 <strong><em>slave</em></strong> 可以是下一个 <strong><em>slave</em></strong> 的 <strong><em>master</em></strong>，<strong><em>slave</em></strong> 同样可以接收其他 <strong><em>slave</em></strong>的连接和同步请求，那么该 <strong><em>slave</em></strong> 作为了链条中下一个的 <strong><em>master</em></strong>，可以有效减轻 <strong><em>master</em></strong> 的写压力，去中心化降低风险。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n905" mdtype="fences">slaveof &lt;ip&gt;&lt;port&gt;
</pre><p>中途变更转向：会清除之前的数据，重新建立拷贝最新的。</p><p>当某个 <strong><em>slave</em></strong> 宕机，后面的 <strong><em>slave</em></strong> 都没法备份。</p><p>即当主机挂掉，从机还是从机，但是无法继续写数据。</p><p>&nbsp;</p><h2><a name='header-n910' class='md-header-anchor '></a>9.4 反客为主</h2><p>当一个 <strong><em>master</em></strong> 宕机后，后面的 <strong><em>slave</em></strong> 可以立刻升为 <strong><em>master</em></strong>，其后面的 <strong><em>slave</em></strong> 不用做任何修改。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n912" mdtype="fences">slaveof no one
</pre><p>&nbsp;</p><h2><a name='header-n914' class='md-header-anchor '></a>9.5 哨兵模式</h2><blockquote><p><strong>反客为主的自动版</strong>，即能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p></blockquote><ol start='' ><li>调整为一主二仆模式，6379带着6380、6381</li><li>创建 <strong><em>sentinel.conf</em></strong> 文件（名字不能错）</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n922" mdtype="fences">/opt/etc/sentinel.conf
</pre><ol start='2' ><li>配置哨兵</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="bash" contenteditable="false" cid="n926" mdtype="fences">sentinel monitor mymaster 172.16.88.168 6379 1

# mymaster：监控对象起的服务器名称
# 1：至少有多少个哨兵同意迁移的数量。 
</pre><ol start='3' ><li>启动哨兵</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n930" mdtype="fences">redis-sentinel  /opt/etc/sentinel.conf 
</pre><p><img src='https://img-blog.csdnimg.cn/7666cd7437114d038c1f185463e97bc6.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>主机挂掉，会从机选举中产生新的主机。选举的规则。</p><ol start='4' ><li><p>redis做压测可以用自带的redis-benchmark工具</p></li><li><p>当主机挂掉，从机选举中产生新的主机</p><blockquote><p>(大概10秒左右可以看到哨兵窗口日志，切换了新的主机)</p><p>哪个从机会被选举为主机呢？根据优先级别：slave-priority </p><p>原主机重启后会变为从机。</p></blockquote></li></ol><p>&nbsp;</p><h3><a name='header-n943' class='md-header-anchor '></a>9.5.1 选举规则</h3><ul><li><p>根据优先级别，<strong><em>slave-priority/replica-priority</em></strong>，优先选择优先级靠前的。</p><p><img src='https://img-blog.csdnimg.cn/06e79e226ed34939889950f6e259dd3e.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>根据偏移量，优先选择偏移量大的。</p></li><li><p>根据 <strong><em>runid</em></strong>，优先选择最小的服务。</p></li></ul><p><img src='https://img-blog.csdnimg.cn/0023f8ed9fcf44279a54f783089d41ba.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><blockquote><p>优先级在redis.conf中默认：slave-priority 100，值越小优先级越高</p><p>偏移量是指获得原主机数据最全的</p><p>每个redis实例启动后都会随机生成一个40位的runid</p></blockquote><h3><a name='header-n956' class='md-header-anchor '></a>9.5.2 复制延时</h3><p>由于所有的写操作都是先在 <strong><em>master</em></strong> 上操作，然后同步更新到 <strong><em>slave</em></strong> 上，所以从 <strong><em>master</em></strong> 同步到 <strong><em>slave</em></strong> 从机有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，<strong><em>slave</em></strong> 机器数量的增加也会使这个问题更加严重。</p><p>&nbsp;</p><h2><a name='header-n959' class='md-header-anchor '></a>9.6 复制原理</h2><ul><li><strong><em>slave</em></strong> 启动成功连接到 <strong><em>master</em></strong> 后会发送一个 <strong><em>sync</em></strong> 命令（同步命令）。</li><li><strong><em>master</em></strong> 接到命令启动后台的存盘进程，对数据进行持久化操作，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<strong><em>master</em></strong> 将传送整个数据文件（<strong><em>rdb</em></strong>）到 <strong><em>slave</em></strong>，以完成一次完全同步。</li><li>当主服务进行写操作后，和从服务器进行数据同步。</li><li>全量复制：而 <strong><em>slave</em></strong> 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：<strong><em>master</em></strong> 继续将新的所有收集到的修改命令依次传给 <strong><em>slave</em></strong>，完成同步。</li><li>只要是重新连接 <strong><em>master</em></strong>，一次完全同步（全量复制）将被自动执行。</li></ul><p>&nbsp;</p><h2><a name='header-n974' class='md-header-anchor '></a>9.7 Java代码</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n975" mdtype="fences" style="break-inside: unset;">private static JedisSentinelPool jedisSentinelPool=null;

public static  Jedis getJedisFromSentinel(){
    
    if (jedisSentinelPool==null) {
        Set&lt;String&gt; sentinelSet=new HashSet&lt;&gt;();
        sentinelSet.add("192.168.11.103:26379");
        JedisPoolConfig jedisPoolConfig =new JedisPoolConfig();
        jedisPoolConfig.setMaxTotal(10); //最大可用连接数
        jedisPoolConfig.setMaxIdle(5); //最大闲置连接数
        jedisPoolConfig.setMinIdle(5); //最小闲置连接数
        jedisPoolConfig.setBlockWhenExhausted(true); //连接耗尽是否等待
        jedisPoolConfig.setMaxWaitMillis(2000); //等待时间
        jedisPoolConfig.setTestOnBorrow(true); //取连接的时候进行一下测试 ping pong

        jedisSentinelPool=new JedisSentinelPool("mymaster",sentinelSet,jedisPoolConfig);
        return jedisSentinelPool.getResource();
    } else {
        return jedisSentinelPool.getResource();
    }
    
}
</pre><p>&nbsp;</p><h1><a name='header-n977' class='md-header-anchor '></a>10. 集群</h1><p>容量不够，<strong><em>redis</em></strong> 如何进行扩容？</p><p>并发写操作， <strong><em>redis</em></strong> 如何分摊？</p><p>主从模式，薪火相传模式，主机宕机，导致 <strong><em>ip</em></strong> 地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p><p>解决方法：无中心化集群配置。</p><ul><li><p>代理主机（ <strong><em>之前</em></strong> ）</p><p><img src='https://img-blog.csdnimg.cn/16abd1c464114185b139ebdc4a362a7a.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' />无中心化集群配置（ <strong><em>redis3.0</em></strong> ）</p></li></ul><p><img src='https://img-blog.csdnimg.cn/2168fca408de47bca4e030bf73a2931a.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong><em>Redis</em></strong> 集群实现了对 <strong><em>Redis</em></strong> 的水平扩容，即启动 <strong><em>N</em></strong> 个 <strong><em>Redis</em></strong> 节点，将整个数据库分布存储在这 <strong><em>N</em></strong> 个节点中，每个节点存储总数据的 <strong><em>1/N</em></strong> 。</p><p><strong><em>Redis</em></strong> 集群通过分区（<strong><em>partition</em></strong>）来提供一定程度的可用性（<strong><em>availability</em></strong>），即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><p>&nbsp;</p><h2><a name='header-n991' class='md-header-anchor '></a>10.1 搭建 <em>Redis</em> 集群</h2><ol start='' ><li>删除持久化数据</li></ol><blockquote><p>将rdb,aof文件都删除掉。</p></blockquote><ol start='' ><li>创建配置文件</li></ol><blockquote><p>开启daemonize yes</p><p>Pid文件名字</p><p>指定端口</p><p>Log文件名字</p><p>Dump.rdb名字</p><p>Appendonly 关掉或者换名字</p></blockquote><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="bash" contenteditable="false" cid="n1007" mdtype="fences"># 以redis6379.conf为例
include /opt/etc/redis.conf
pidfile /var/run/redis_6379.pid # 更改
port 6379 # 更改
dbfilename dump6379.rdb # 更改
cluster-enabled yes # 打开集群模式
cluster-config-file nodes-6379.conf # 设置节点配置文件名称，需要更改
cluster-node-timeout 15000 # 设置节点失联事件，超过该时间（ms），集群自动进行主从切换
</pre><ol start='2' ><li>启动</li></ol><p><img src='https://img-blog.csdnimg.cn/58260f50b2d245f981caf56a9efaaa82.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><img src='https://img-blog.csdnimg.cn/3b48561608d64b5d87119563defbcc24.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><ol start='3' ><li>将 6 个节点合成一个集群</li></ol><p>组合之前请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</p><p><img src='https://img-blog.csdnimg.cn/798a784076ad48708511c5316c12da73.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="bash" contenteditable="false" cid="n1018" mdtype="fences"># 进入redis安装目录
/opt/redis-6.2.6/src

# 执行 不要用127.0.0.1 使用真实地址
# --replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。
redis-cli --cluster create --cluster-replicas 1 172.16.88.168:6379 172.16.88.168:6380 172.16.88.168:6381 172.16.88.168:6389 172.16.88.168:6390 172.16.88.168:6391
</pre><p><img src='https://img-blog.csdnimg.cn/ee6d91a112054eff8d920bc054566cb5.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><ol start='4' ><li>采用集群策略连接</li></ol><blockquote><p>l  普通方式登录</p><p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。</p><p>-c：采用集群策略连接，设置数据会自动切换到相应的写主机</p></blockquote><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="bash" contenteditable="false" cid="n1027" mdtype="fences">cd /opt/redis-6.2.6/src
redis-cli -c -p PORT
cluster nodes # 命令查看集群信息
</pre><p><img src='https://img-blog.csdnimg.cn/b28784c3031047a1a21f9554d27c9f31.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><h2><a name='header-n1029' class='md-header-anchor '></a>10.2 问题</h2><h3><a name='header-n1030' class='md-header-anchor '></a>10.2.1 <em>redis cluster</em> 如何分配这六个节点?</h3><blockquote><p>一个集群至少要有三个主节点。</p><p>选项 <code>--cluster-replicas 1</code>，表示希望为集群中的每个主节点创建一个从节点。</p><p>分配原则尽量保证每个主数据库运行在不同的 <strong><em>IP</em></strong> 地址，每个从库和主库不在一个 <strong><em>IP</em></strong> 地址上。</p><p><img src='https://img-blog.csdnimg.cn/25b1355861e3420084966bb504748a53.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></blockquote><h3><a name='header-n1036' class='md-header-anchor '></a>10.2.2 什么是 <em>slots</em>？</h3><p><img src='https://img-blog.csdnimg.cn/ab79215a381c489aaeca30647662bfff.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><img src='https://img-blog.csdnimg.cn/fedf3d2e243d44f78a75e04bfe5e5717.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><blockquote><p>一个 <strong><em>Redis</em></strong> 集群包含 <strong><em>16384</em></strong> 个插槽（<strong><em>hash slot</em></strong>）， 数据库中的每个键都属于这 <strong><em>16384</em></strong> 个插槽的其中一个。</p><p>集群使用公式 <strong><em>CRC16(key) % 16384</em></strong> 来计算键 <strong><em>key</em></strong> 属于哪个槽， 其中 <strong><em>CRC16(key)</em></strong> 语句用于计算键 <strong><em>key</em></strong> 的 <strong><em>CRC16</em></strong> 校验和 。</p><p>集群中的每个节点负责处理一部分插槽。 例如， 如果一个集群可以有主节点， 其中：</p><ul><li>节点 <strong><em>A</em></strong> 负责处理 <strong><em>0</em></strong> 号至 <strong><em>5460</em></strong> 号插槽。</li><li>节点 <strong><em>B</em></strong> 负责处理 <strong><em>5461</em></strong> 号至 <strong><em>10922</em></strong> 号插槽。</li><li>节点 <strong><em>C</em></strong> 负责处理 <strong><em>10923</em></strong> 号至 <strong><em>16383</em></strong> 号插槽。</li></ul></blockquote><h3><a name='header-n1050' class='md-header-anchor '></a>10.2.3 如何在集群中录入值？</h3><blockquote><p>在 <strong><em>redis-cli</em></strong> 每次录入、查询键值，<strong><em>redis</em></strong> 都会计算出该 <strong><em>key</em></strong> 应该送往的插槽，如果不是该客户端对应服务器的插槽，<strong><em>redis</em></strong> 会报错，并告知应前往的 <strong><em>redis</em></strong> 实例地址和端口。</p><p><strong><em>redis-cli</em></strong> 客户端提供了 <strong><em>–c</em></strong> 参数实现自动重定向。</p><p>例如 <strong><em>redis-cli -c –p 6379</em></strong> 登入后，再录入、查询键值对可以自动重定向。</p><p>不在一个slot下的键值，是不能使用mget,mset等多键操作。</p><p><img src='https://img-blog.csdnimg.cn/cfea50fb04e34f2c89b6cefd6e832c8e.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。</p><p><img src='https://img-blog.csdnimg.cn/47849e40474b4a9a94679d5ce373b5a1.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></blockquote><h3><a name='header-n1059' class='md-header-anchor '></a>10.2.4 如何查询集群中的值？</h3><blockquote><p>每个主机只能查询自己范围内部的插槽。</p><p><code>cluster keyslot &lt;key&gt;</code>：查询某个 <strong><em>key</em></strong> 的 <strong><em>slot</em> </strong>。</p><p><code>cluster countkeysinslot &lt;slot&gt;</code>：查询某个 <strong><em>slot</em></strong> 是否有值。（只能看自己的插槽中的值）</p><p><code>CLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt;</code>：返回 <strong><em>count</em></strong> 个 <strong><em>slot</em></strong> 槽中的键。</p></blockquote><h3><a name='header-n1065' class='md-header-anchor '></a>10.2.5 故障恢复？</h3><blockquote><p>如果主节点下线？从节点能否自动升为主节点？注意：<strong><em>15</em></strong> 秒超时。</p><p><img src='https://img-blog.csdnimg.cn/b647ea6dddca4009a31786d40fe25439.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><ul><li>当 <strong><em>6379</em></strong> 挂掉后，<strong><em>6389</em></strong> 成为新的主机。</li></ul><p>&nbsp;</p><p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p><ul><li>当 <strong><em>6379</em></strong> 重启后，<strong><em>6379</em></strong> 成为 <strong><em>6389</em></strong> 的从机。</li></ul><p>&nbsp;</p><p>如果所有某一段插槽的主从节点都宕掉，<strong><em>redis</em></strong> 服务是否还能继续?</p><ul><li>如果某一段插槽的主从都挂掉，而 <strong><em>cluster-require-full-coverage=yes</em></strong>，那么 ，整个集群都挂掉。</li><li>如果某一段插槽的主从都挂掉，而 <strong><em>cluster-require-full-coverage=no</em></strong>，那么，该段插槽数据全都不能使用，也无法存储，其他插槽依旧可以使用。</li></ul><p><code>redis.conf</code> 中的参数 <code>cluster-require-full-coverage</code></p></blockquote><h2><a name='header-n1085' class='md-header-anchor '></a>10.3 优点</h2><ul><li>实现扩容；</li><li>分摊压力；</li><li>无中心配置相对简单。</li></ul><h2><a name='header-n1093' class='md-header-anchor '></a>10.4 缺点</h2><ul><li>多键操作是不被支持的；</li><li>多键的 <strong><em>Redis</em></strong> 事务是不被支持的。<strong><em>lua</em></strong> 脚本不被支持；</li><li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至<strong><em>redis cluster</em></strong>，需要整体迁移而不是逐步过渡，复杂度较大。</li></ul><h2><a name='header-n1101' class='md-header-anchor '></a>10.5 <em>Jedis</em>集群</h2><blockquote><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p><p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p></blockquote><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1105" mdtype="fences">public class JedisClusterTest {
  public static void main(String[] args) { 
     Set&lt;HostAndPort&gt;set =new HashSet&lt;HostAndPort&gt;();
     set.add(new HostAndPort("172.16.88.168",6379)); // 任何一个端口
     JedisCluster jedisCluster = new JedisCluster(set);
     jedisCluster.set("k1", "v1");
     System.out.println(jedisCluster.get("k1"));
     jedisCluster.close();
  }
}
</pre><p>&nbsp;</p><h1><a name='header-n1107' class='md-header-anchor '></a>11. Jedis操作Redis</h1><p>即 <strong><em>Java</em></strong> 操作 <strong><em>Redis</em></strong>。</p><ol start='' ><li>依赖</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="xml" contenteditable="false" cid="n1112" mdtype="fences">&lt;dependency&gt;
  &lt;groupId&gt;redis.clients&lt;/groupId&gt;
  &lt;artifactId&gt;jedis&lt;/artifactId&gt;
  &lt;version&gt;3.2.0&lt;/version&gt;
&lt;/dependency&gt;
</pre><ol start='2' ><li>连接 <strong><em>Redis</em></strong></li></ol><blockquote><p>防火墙关闭或开放指定端口号：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="bash" contenteditable="false" cid="n1118" mdtype="fences">systemctl status firewalld
systemctl stop firewalld
</pre></blockquote><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1119" mdtype="fences">public class JedisDemo {
  public static void main(String[] args) {
    Jedis jedis = new Jedis("192.168.182.128", 6379);
    String pong = jedis.ping();
    System.out.println("连接成功：" + pong);// 连接成功：PONG
    jedis.close();
  }
}
</pre><blockquote><p><strong><em>Key</em></strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1122" mdtype="fences">jedis.set("k1", "v1");
jedis.set("k2", "v2");
jedis.set("k3", "v3");
Set&lt;String&gt; keys = jedis.keys("*");
System.out.println(keys.size());
for (String key : keys) {
	System.out.println(key);
}
System.out.println(jedis.exists("k1"));
System.out.println(jedis.ttl("k1"));                
System.out.println(jedis.get("k1"));
</pre><p><strong><em>String</em></strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1124" mdtype="fences">jedis.mset("str1","v1","str2","v2","str3","v3");
System.out.println(jedis.mget("str1","str2","str3"));
</pre><p><strong><em>List</em></strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1126" mdtype="fences">List&lt;String&gt; list = jedis.lrange("mylist",0,-1);
for (String element : list) {
	System.out.println(element);
}
</pre><p><strong><em>Set</em></strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1128" mdtype="fences">jedis.sadd("orders", "order01");
jedis.sadd("orders", "order02");
jedis.sadd("orders", "order03");
jedis.sadd("orders", "order04");
Set&lt;String&gt; smembers = jedis.smembers("orders");
for (String order : smembers) {
	System.out.println(order);
}
jedis.srem("orders", "order02");
</pre><p><strong><em>Hash</em></strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1130" mdtype="fences">jedis.hset("hash1","userName","lisi");
System.out.println(jedis.hget("hash1","userName"));
Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();
map.put("telphone","13810169999");
map.put("address","atguigu");
map.put("email","abc@163.com");
jedis.hmset("hash2",map);
List&lt;String&gt; result = jedis.hmget("hash2", "telphone","email");
for (String element : result) {
	System.out.println(element);
}
</pre><p><strong><em>zset</em></strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1132" mdtype="fences">jedis.zadd("zset01", 100d, "z3");
jedis.zadd("zset01", 90d, "l4");
jedis.zadd("zset01", 80d, "w5");
jedis.zadd("zset01", 70d, "z6");
Set&lt;String&gt; zrange = jedis.zrange("zset01", 0, -1);
for (String e : zrange) {
	System.out.println(e);
}
</pre></blockquote><h2><a name='header-n1133' class='md-header-anchor '></a>11.1 手机验证码发送模拟</h2><p><img src='https://img-blog.csdnimg.cn/6d0c8a5afec74165bd6509c50c2f30bf.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><img src='https://img-blog.csdnimg.cn/c2129d00d47548aab2ad5a700a5eba85.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1136" mdtype="fences" style="break-inside: unset;">import java.util.Random
public class PhoneCode{
	public static void main(String[] args){
		//模拟验证码发送
		verifyCode("16387622121");
		//获取验证码进行判断
		getRedisCode("16387622121");
	}
	
	// 3.验证码校验
	public static void getRedisCode(String phone,String code){
		//从redis获取验证码
		Jedis jedis = new Jedis("192.168.182.128",6379);
		//验证码key
		String codeKey = "VerifyCode"+phone+":code";
		String redisCode = jedis.get(codeKey);
		//判断
		if (redisCode.equals(code)){
			System.out.println("成功");
		} else {
			System.out.println("失败");
		}
		jedis.close();
	}
	
	// 2.每个手机每天发送三次，验证码放到redis中，设置过期时间120s
	public static void verifyCode(String phone){
		//连接redis
		Jedis jedis = new Jedis("192.168.182.128",6379);
		//拼接key
		//手机发送次数key
		String countKey = "VerifyCode"+phone+":count";
		//验证码key
		String codeKey = "verifyCode"+phone+":code";
		//每个手机每天只能发送三次
		String count = jedis.get(countKey);
		if(count==null){
			//没有发送次数，第一次发送，设置发送次数为1
			jedis.setex(countKey,24*60*60L,"1");
		} else if (Integer.parseInt(count) &lt;= 2) {
			//发送次数+1
			jedis.incr(countKey);
		} else if (Integer.parseInt(count) &gt; 2) {
			//发送三次，不能再次发送
			System.out.println("发送次数上限！");
			jedis.close();
			return;
		}
		//发送验证码到redis里面
		String vcode = getCode();
		jedis.setex(codeKey,120,vcode);
		jedis.close();
	}
	
	// 1.生成6位数字验证码
	public static String getCode(){
        Random random = new Random();
        String code = "";
        for(int i = 0;i&lt;3;++i){
            int rand = random.nextInt(10);
            code += rand;
        }
        return code;
	}
}
</pre><h2><a name='header-n1137' class='md-header-anchor '></a>11.2 <em>Jedis</em> 主从复制</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1138" mdtype="fences" style="break-inside: unset;">private static JedisSentinelPool jedisSentinelPool=null;

public static  Jedis getJedisFromSentinel(){

  if (jedisSentinelPool==null) {
    Set&lt;String&gt; sentinelSet=new HashSet&lt;&gt;();
    sentinelSet.add("172.16.88.168:26379"); // 端口为sentinal
    JedisPoolConfig jedisPoolConfig =new JedisPoolConfig();
    jedisPoolConfig.setMaxTotal(10); // 最大可用连接数
    jedisPoolConfig.setMaxIdle(5); // 最大闲置连接数
    jedisPoolConfig.setMinIdle(5); // 最小闲置连接数
    jedisPoolConfig.setBlockWhenExhausted(true); // 连接耗尽是否等待
    jedisPoolConfig.setMaxWaitMillis(2000); // 等待时间
    jedisPoolConfig.setTestOnBorrow(true); // 取连接的时候进行测试

    jedisSentinelPool=new JedisSentinelPool("mymaster",sentinelSet,jedisPoolConfig); // 服务主机名
    return jedisSentinelPool.getResource();
  }
  else {
    return jedisSentinelPool.getResource();
  }
}
</pre><h2><a name='header-n1139' class='md-header-anchor '></a>11.3 集群的 <em>Jedis</em> 开发</h2><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p><p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1142" mdtype="fences">public class JedisClusterTest {
  public static void main(String[] args) { 
     Set&lt;HostAndPort&gt;set =new HashSet&lt;HostAndPort&gt;();
     set.add(new HostAndPort("172.16.88.168",6379)); // 任何一个端口
     JedisCluster jedisCluster = new JedisCluster(set);
     jedisCluster.set("k1", "v1");
     System.out.println(jedisCluster.get("k1"));
     jedisCluster.close();
  }
}
</pre><h1><a name='header-n1143' class='md-header-anchor '></a>12. SpringBoot整合Redis</h1><ol start='' ><li>添加依赖</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="xml" contenteditable="false" cid="n1147" mdtype="fences">&lt;!-- redis --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- spring2.X集成redis所需common-pool2--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
  &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
  &lt;version&gt;2.6.0&lt;/version&gt;
&lt;/dependency&gt;
</pre><ol start='2' ><li>application.properties配置文件配置 <strong><em>Redis</em></strong></li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="properties" contenteditable="false" cid="n1151" mdtype="fences" style="break-inside: unset;">#Redis服务器地址
spring.redis.host= ip
#Redis服务器连接端口
spring.redis.port=6379
#Redis数据库索引（默认为0）
spring.redis.database= 0
#连接超时时间（毫秒）
spring.redis.timeout=1800000
#连接池最大连接数（使用负值表示没有限制）
spring.redis.lettuce.pool.max-active=20
#最大阻塞等待时间(负数表示没限制)
spring.redis.lettuce.pool.max-wait=-1
#连接池中的最大空闲连接
spring.redis.lettuce.pool.max-idle=5
#连接池中的最小空闲连接
spring.redis.lettuce.pool.min-idle=0
</pre><ol start='3' ><li><strong><em>Redis</em></strong> 配置类（需要继承 <strong><em>CachingConfigurerSupport</em></strong>）</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1155" mdtype="fences" style="break-inside: unset;">@EnableCaching // 开启缓存
@Configuration
public class RedisConfig extends CachingConfigurerSupport {
    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        template.setConnectionFactory(factory);
				// key序列化方式
        template.setKeySerializer(redisSerializer);
				// value序列化
        template.setValueSerializer(jackson2JsonRedisSerializer);
				// value hashmap序列化
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        return template;
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
				// 解决查询缓存转换异常的问题
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
				// 配置序列化（解决乱码的问题）,过期时间600秒
        RedisCacheConfiguration config = 
          RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofSeconds(600))
      .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))
                .disableCachingNullValues();
        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .build();
        return cacheManager;
    }
}
</pre><ol start='4' ><li>测试</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1159" mdtype="fences" style="break-inside: unset;">@RestController
@RequestMapping("/redisTest")
public class RedisTestController {
    @Autowired
    private RedisTemplate redisTemplate;

    @GetMapping
    public String testRedis() {
        //设置值到redis
        redisTemplate.opsForValue().set("name","lucy");
        //从redis获取值
        String name = (String)redisTemplate.opsForValue().get("name");
        return name;
    }
}
</pre><h1><a name='header-n1160' class='md-header-anchor '></a>13. 应用问题解决</h1><h2><a name='header-n1161' class='md-header-anchor '></a>13.1 缓存穿透</h2><p><img src='https://img-blog.csdnimg.cn/b3a2b257c5404c159d9250162e1fdf02.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><h3><a name='header-n1163' class='md-header-anchor '></a>13.1.1 现象</h3><p><img src='https://img-blog.csdnimg.cn/a7378e6ed6694b82af007c228fe9117b.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong><em>key</em></strong> 对应的数据在数据源并不存在，每次针对此 <strong><em>key</em></strong> 的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。</p><p>比如用一个不存在的用户 <strong><em>id</em></strong> 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><p>造成：</p><ol start='' ><li>应用服务器压力变大。</li><li><strong><em>redis</em></strong> 命中率下降 <span class="MathJax_SVG" tabindex="-1" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.804ex" height="1.644ex" viewBox="0 -605.1 1638 707.6" role="img" focusable="false" style="vertical-align: -0.238ex;"><defs><path stroke-width="0" id="E3-MJMAIN-27F6" d="M84 237T84 250T98 270H1444Q1328 357 1301 493Q1301 494 1301 496T1300 499Q1300 511 1317 511H1320Q1329 511 1332 510T1338 506T1341 497T1344 481T1352 456Q1374 389 1425 336T1544 261Q1553 258 1553 250Q1553 244 1548 241T1524 231T1486 212Q1445 186 1415 152T1370 85T1349 35T1341 4Q1339 -6 1336 -8T1320 -11Q1300 -11 1300 0Q1300 7 1305 25Q1337 151 1444 230H98Q84 237 84 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E3-MJMAIN-27F6" x="0" y="0"></use></g></svg></span><script type="math/tex">\longrightarrow</script> 查询数据库 。</li></ol><p><img src='https://img-blog.csdnimg.cn/9cc47688c2de463581f0b8e6c88e56b1.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><h3><a name='header-n1174' class='md-header-anchor '></a>13.1.2 如何解决</h3><ul><li><p><strong>对空值缓存</strong></p><p>如果一个查询返回的数据为空（不管是数据是否不存在），仍然把这个空结果（<strong><em>null</em></strong>）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</p></li><li><p><strong>设置可访问的名单（白名单）：</strong></p><p>使用 <strong><em>bitmaps</em></strong> 类型定义一个可以访问的名单，名单 <strong><em>id</em></strong> 作为 <strong><em>bitmaps</em></strong> 的偏移量，每次访问和 <strong><em>bitmap</em></strong> 里面的 <strong><em>id</em></strong> 进行比较，如果访问 <strong><em>id</em></strong> 不在 <strong><em>bitmaps</em></strong> 里面，进行拦截，则不允许访问。</p></li><li><p><strong>采用布隆过滤器</strong></p><p>布隆过滤器（<strong><em>Bloom Filter</em></strong>）是1970年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>将所有可能存在的数据哈希到一个足够大的 <strong><em>bitmaps</em></strong> 中，一个一定不存在的数据会被这个 <strong><em>bitmaps</em></strong> 拦截掉，从而避免了对底层存储系统的查询压力。</p></li><li><p><strong>进行实时监控</strong></p><p>当发现 <strong><em>Redis</em></strong> 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p></li></ul><p>&nbsp;</p><h2><a name='header-n1191' class='md-header-anchor '></a>13.2 缓存击穿</h2><h3><a name='header-n1192' class='md-header-anchor '></a>13.2.1 现象</h3><p><img src='https://img-blog.csdnimg.cn/f9ca2b95b4034c1ca2419e6fcbb87b95.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /><strong><em>key</em></strong> 对应的数据存在，但在 <strong><em>redis</em></strong> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<strong><em>DB</em></strong> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <strong><em>DB</em></strong> 压垮。</p><ol start='' ><li>数据库访问压力瞬间增大。</li><li><strong><em>redis</em></strong> 中没有出现大量 <strong><em>key</em></strong> 过期，<strong><em>redis</em></strong> 正常运行。</li><li>（即某个经常访问的 <strong><em>key</em></strong> 过期，突然有大量访问这个数据）</li></ol><h3><a name='header-n1201' class='md-header-anchor '></a>13.2.2 如何解决</h3><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p><ul><li><p>预先设置热门数据</p><p>在 <strong><em>redis</em></strong> 高峰访问之前，把一些热门数据提前存入到 <strong><em>redis</em></strong> 里面，加大这些热门数据 <strong><em>key</em></strong> 的时长。</p></li><li><p>实时调整</p><p>现场监控哪些数据热门，实时调整 <strong><em>key</em></strong> 的过期时长。</p></li><li><p>使用锁</p><p>（1）    就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</p><p>（2）    先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</p><p>（3）    当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</p><p>（4）    当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</p></li></ul><p><img src='https://img-blog.csdnimg.cn/524a22b4b5e0433e8a2bfd70a01a1d51.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><h2><a name='header-n1217' class='md-header-anchor '></a>13.3 缓存雪崩</h2><h3><a name='header-n1218' class='md-header-anchor '></a>13.3.1 现象</h3><p><strong><em>key</em></strong> 对应的数据存在，但在 <strong><em>redis</em></strong> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<strong><em>DB</em></strong> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <strong><em>DB</em></strong> 压垮。</p><p>缓存雪崩与缓存击穿的区别在于这里针对很多 <strong><em>key</em></strong> 缓存，前者则是某一个 <strong><em>key</em></strong>。</p><ol start='' ><li>数据库压力变大。</li><li>即极少的时间段，查询大量 <strong><em>key</em></strong> 的集中过期情况。</li></ol><h3><a name='header-n1226' class='md-header-anchor '></a>13.3.2 如何解决</h3><ul><li><p><strong>构建多级缓存架构</strong></p><p><strong><em>nginx</em></strong> 缓存 + <strong><em>redis</em></strong> 缓存 + 其他缓存（<strong><em>ehcache</em></strong>等）</p></li><li><p><strong>使用锁或队列：</strong></p><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。</p></li><li><p><strong>设置过期标志更新缓存：</strong></p><p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 <strong><em>key</em></strong> 的缓存。</p></li><li><p><strong>将缓存失效时间分散开：</strong></p><p>比如我们可以在原有的失效时间基础上增加一个随机值，比如 1～5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p></li></ul><p>&nbsp;</p><h2><a name='header-n1241' class='md-header-anchor '></a>13.4 分布式锁</h2><h3><a name='header-n1242' class='md-header-anchor '></a>13.4.1 问题描述</h3><blockquote><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p><p>分布式锁主流的实现方案：</p><ol start='' ><li>基于数据库实现分布式锁</li><li>基于缓存（Redis等）</li><li>基于Zookeeper</li></ol><p>每一种分布式锁解决方案都有各自的优缺点：</p><ol start='' ><li>性能：redis最高</li><li>可靠性：zookeeper最高</li></ol><p>这里，我们就基于redis实现分布式锁。</p></blockquote><hr /><h3><a name='header-n1261' class='md-header-anchor '></a>13.4.2 redis实现分布式锁</h3><p><img src='https://img-blog.csdnimg.cn/97ca432e1c8c4528aa78530f611cd878.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>redis：<code>set sku:1:info “OK” NX PX 10000</code></p><blockquote><p>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</p><p>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</p><p>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p><p>XX ：只在键已经存在时，才对键进行设置操作。</p></blockquote><p><img src='https://img-blog.csdnimg.cn/484f1ef73ffa436caab3f89f28b13784.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><blockquote><ol start='' ><li>多个客户端同时获取锁（setnx）</li><li>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</li><li>其他客户端等待重试</li></ol></blockquote><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="bash" contenteditable="false" cid="n1278" mdtype="fences">setnx users 10
expire users 10
ttl users
</pre><h3><a name='header-n1279' class='md-header-anchor '></a>13.4.3 Java代码</h3><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1280" mdtype="fences" style="break-inside: unset;">@GetMapping("testLock")
public void testLock(){
    //1获取锁，setne
    Boolean lock = redisTemplate.opsForValue().setIfAbsent("lock", "111");
    //2获取锁成功、查询num的值
    if(lock){
        Object value = redisTemplate.opsForValue().get("num");
        //2.1判断num为空return
        if(StringUtils.isEmpty(value)){
            return;
        }
        //2.2有值就转成成int
        int num = Integer.parseInt(value+"");
        //2.3把redis的num加1
        redisTemplate.opsForValue().set("num", ++num);
        //2.4释放锁，del
        redisTemplate.delete("lock");

    }else{
        //3获取锁失败、每隔0.1秒再获取
        try {
            Thread.sleep(100);
            testLock();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</pre><blockquote><p>重启，服务集群，通过网关压力测试：</p><p>ab -n 1000 -c 100 <a href='http://192.168.140.1:8080/test/testLock' target='_blank' class='url'>http://192.168.140.1:8080/test/testLock</a></p><p>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放</p><p>解决：设置过期时间，自动释放锁。</p></blockquote><h3><a name='header-n1286' class='md-header-anchor '></a>13.4.4 设置过期时间</h3><p>设置过期时间有两种方式：</p><ol start='' ><li>首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</li><li>在set时指定过期时间（推荐）</li></ol><p><img src='https://img-blog.csdnimg.cn/3797fb2bb97d42dbbf3f992583062be9.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>设置过期时间：</p><p><img src='https://img-blog.csdnimg.cn/837cda0262bc4244b81a39fce49cff10.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>场景：如果业务逻辑的执行时间是7s。执行流程如下：</p><ol start='' ><li>index1业务逻辑没执行完，3秒后锁被自动释放。</li><li>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</li><li>index3获取到锁，执行业务逻辑</li><li>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</li></ol><p>最终等于没锁的情况。</p><p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p><h3><a name='header-n1308' class='md-header-anchor '></a>13.4.5 优化之UUID防误删</h3><p><img src='https://img-blog.csdnimg.cn/d114aacc71804a2ba31b885c850a114f.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><img src='https://img-blog.csdnimg.cn/198d840d69cc46cda7a186c411bf6ce8.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>场景：</p><ol start='' ><li><p>index1执行删除时，查询到的lock值确实和uuid相等</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1315" mdtype="fences">uuid=v1
set(lock,uuid)；
</pre></li><li><p>index1执行删除前，lock刚好过期时间已到，被redis自动释放</p><p>在redis中没有了lock，没有了锁。</p></li><li><p>index2获取了lock</p><p>index2线程获取到了cpu的资源，开始执行方法。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1322" mdtype="fences">uuid=v2
set(lock,uuid)；
</pre></li><li><p>index1执行删除，此时会把index2的lock删除</p><p>index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。index1已经比较完成了，这个时候，开始执行。</p><p>删除的index2的锁！</p></li></ol><h3><a name='header-n1327' class='md-header-anchor '></a>13.4.6 优化之LUA脚本保证删除的原子性</h3><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1328" mdtype="fences" style="break-inside: unset;">@GetMapping("testLockLua")
public void testLockLua() {
    //1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中
    String uuid = UUID.randomUUID().toString();
    //2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！
    String skuId = "25"; // 访问skuId 为25号的商品 100008348542
    String locKey = "lock:" + skuId; // 锁住的是每个商品的数据

    // 3 获取锁
    Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid, 3, TimeUnit.SECONDS);

    // 第一种： lock 与过期时间中间不写任何的代码。
    // redisTemplate.expire("lock",10, TimeUnit.SECONDS);//设置过期时间
    // 如果true
    if (lock) {
        // 执行的业务逻辑开始
        // 获取缓存中的num 数据
        Object value = redisTemplate.opsForValue().get("num");
        // 如果是空直接返回
        if (StringUtils.isEmpty(value)) {
            return;
        }
        // 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！
        int num = Integer.parseInt(value + "");
        // 使num 每次+1 放入缓存
        redisTemplate.opsForValue().set("num", String.valueOf(++num));
        /*使用lua脚本来锁*/
        // 定义lua 脚本
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
        // 使用redis执行lua执行
        DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();
        redisScript.setScriptText(script);
        // 设置一下返回值类型 为Long
        // 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，
        // 那么返回字符串与0 会有发生错误。
        redisScript.setResultType(Long.class);
        // 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。
        redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);
    } else {
        // 其他线程等待
        try {
            // 睡眠
            Thread.sleep(1000);
            // 睡醒了之后，调用方法。
            testLockLua();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</pre><p>LUA脚本详解：</p><p><img src='https://img-blog.csdnimg.cn/f9273455526c461e9d2f20a2ec4e821a.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>项目中正常使用：</p><ol start='' ><li><p>定义key，key应该是为每个sku定义的，也就是每个sku有一把锁。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1335" mdtype="fences">String locKey ="lock:"+skuId; // 锁住的是每个商品的数据
Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid,3,TimeUnit.SECONDS);
</pre><p><img src='https://img-blog.csdnimg.cn/3d5742f1d9e643c29d381ec9b9a2f7d4.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p></li></ol><h3><a name='header-n1339' class='md-header-anchor '></a>13.4.7 总结</h3><ol start='' ><li><p>加锁：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1343" mdtype="fences">// 1. 从redis中获取锁,set k1 v1 px 20000 nx
String uuid = UUID.randomUUID().toString();
Boolean lock = this.redisTemplate.opsForValue().setIfAbsent("lock", uuid, 2, TimeUnit.SECONDS);
</pre></li><li><p>使用lua释放锁：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1346" mdtype="fences">// 2. 释放锁 del
String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
// 设置lua脚本返回的数据类型
DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();
// 设置lua脚本返回类型为Long
redisScript.setResultType(Long.class);
redisScript.setScriptText(script);
redisTemplate.execute(redisScript, Arrays.asList("lock"),uuid);
</pre></li><li><p>重试：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1349" mdtype="fences">Thread.sleep(500);
testLock();
</pre></li></ol><blockquote><p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p><ul><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li><li>加锁和解锁必须具有原子性。</li></ul></blockquote><p>&nbsp;</p><h1><a name='header-n1362' class='md-header-anchor '></a>14. Redis6新特性</h1><h2><a name='header-n1363' class='md-header-anchor '></a>14.1 ACL</h2><h3><a name='header-n1364' class='md-header-anchor '></a>14.1.1 简介</h3><blockquote><p>Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。</p><p>在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ：</p><p>（1）接入权限:用户名和密码 </p><p>（2）可以执行的命令 </p><p>（3）可以操作的 KEY</p><p>参考官网：<a href='https://redis.io/topics/acl' target='_blank' class='url'>https://redis.io/topics/acl</a></p></blockquote><h3><a name='header-n1372' class='md-header-anchor '></a>14.1.2 命令</h3><p>1、使用acl list命令展现用户权限列表</p><p>（1）数据说明</p><p><img src='https://img-blog.csdnimg.cn/8701176f56e64a4badad1b91c3aaa882.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>2、使用acl cat命令</p><p>（1）查看添加权限指令类别</p><p><img src='https://img-blog.csdnimg.cn/0f13e080862f453d89e7fd145dd2a58f.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>（2）加参数类型名可以查看类型下具体命令</p><p><img src='https://img-blog.csdnimg.cn/cd2377a067d74107bc344a388489bc38.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>3、使用acl whoami命令查看当前用户</p><p><img src='https://img-blog.csdnimg.cn/850b6f87585642198d255b89822bb41c.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>4、使用aclsetuser命令创建和编辑用户ACL</p><p>（1）ACL规则</p><p>下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</p><figure><table><thead><tr><th>ACL规则</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td>类型</td><td>参数</td><td>说明</td></tr><tr><td>启动和禁用用户</td><td><strong>on</strong></td><td>激活某用户账号</td></tr><tr><td><strong>off</strong></td><td>禁用某用户账号。注意，已验证的连接仍然可以工作。如果默认用户被标记为off，则新连接将在未进行身份验证的情况下启动，并要求用户使用AUTH选项发送AUTH或HELLO，以便以某种方式进行身份验证。</td><td>&nbsp;</td></tr><tr><td>权限的添加删除</td><td><strong>+<command></strong></td><td>将指令添加到用户可以调用的指令列表中</td></tr><tr><td><strong>-<command></strong></td><td>从用户可执行指令列表移除指令</td><td>&nbsp;</td></tr><tr><td><strong>+@<category></strong></td><td>添加该类别中用户要调用的所有指令，有效类别为@admin、@set、@sortedset…等，通过调用ACL CAT命令查看完整列表。特殊类别@all表示所有命令，包括当前存在于服务器中的命令，以及将来将通过模块加载的命令。</td><td>&nbsp;</td></tr><tr><td>-@<actegory></td><td>从用户可调用指令中移除类别</td><td>&nbsp;</td></tr><tr><td><strong>allcommands</strong></td><td>+@all的别名</td><td>&nbsp;</td></tr><tr><td><strong>nocommand</strong></td><td>-@all的别名</td><td>&nbsp;</td></tr><tr><td>可操作键的添加或删除</td><td><strong>~<pattern></strong></td><td>添加可作为用户可操作的键的模式。例如~*允许所有的键</td></tr></tbody></table></figure><p>（2）通过命令创建新用户默认权限</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="bash" contenteditable="false" cid="n1432" mdtype="fences">acl setuser user1
</pre><p><img src='https://img-blog.csdnimg.cn/d5add13bc5b34fa2a98834df96b5c158.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用just
created的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。</p><p>（3）设置有用户名、密码、ACL权限、并启用的用户</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1436" mdtype="fences">acl setuser user2 on &gt;password ~cached:* +get
</pre><p><img src='https://img-blog.csdnimg.cn/e094534ba352451c829d18223059ab88.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>(4)切换用户，验证权限</p><p><img src='https://img-blog.csdnimg.cn/c6278e8374ef4354802f49c46cf43016.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><h2><a name='header-n1440' class='md-header-anchor '></a>14.2 IO多线程</h2><h3><a name='header-n1441' class='md-header-anchor '></a>14.2.1 简介</h3><p>Redis6终于支撑多线程了，告别单线程了吗？</p><p>IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong>。Redis6执行命令依然是单线程。</p><h3><a name='header-n1444' class='md-header-anchor '></a>14.2.2 原理架构</h3><p>Redis
6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP
等等的并发问题。整体的设计大体如下:</p><p><img src='https://img-blog.csdnimg.cn/6e7b6edd5f434527b071f416f22e7e1e.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>另外，多线程IO默认也是不开启的，需要再配置文件中配置</p><p>io-threads-do-reads  yes </p><p>io-threads 4</p><h3><a name='header-n1450' class='md-header-anchor '></a>14.2.3 工具支持Cluster</h3><p>之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。</p><p><img src='https://img-blog.csdnimg.cn/188fe8b81a414ef088cb019e06fed83a.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><h2><a name='header-n1453' class='md-header-anchor '></a>14.3 Redis新功能持续关注</h2><blockquote><p>Redis6新功能还有：</p><p>1、RESP3新的 Redis 通信协议：优化服务端与客户端之间通信</p><p>2、Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。</p><p>3、Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。</p><p>4、Modules API</p><p>Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。</p></blockquote><p>&nbsp;</p><h1><a name='header-n1462' class='md-header-anchor '></a>15. 后会有期</h1><blockquote><p>路漫漫其修远兮，吾将上下而求索</p><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote></div>
</body>
</html>